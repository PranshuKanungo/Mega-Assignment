create database mysql_assignment_db1;

use mysql_assignment_db1;


--Q1. Query all columns for all American cities in the CITY table with populations larger than 100000.
--The CountryCode for America is USA.
--The CITY table is described as follows:

create table CITY
(
    ID int,
    NAME VARCHAR(17),
    COUNTRYCODE VARCHAR(3),
    DISTRICT VARCHAR(20),
    POPULATION int
);

describe CITY;


insert into CITY VALUES(6,'Rotterdam','NLD','Zuid-Holland',593321);
insert into CITY VALUES(3878,'Scottsdale','USA','Arizona',202705);
insert into CITY VALUES(3965,'Corona','USA','California',124966);
insert into CITY VALUES(3973,'Concord','USA','California',121780);
insert into CITY VALUES(3977,'Cedar Rapids','USA','Iowa',120758);
insert into CITY VALUES(3982,'Coral Springs','USA','Florida',117549);
insert into CITY VALUES(4054,'Fairfield','USA','California',92256);
insert into CITY VALUES(4058,'Boulder','USA','Colorado',91238);
insert into CITY VALUES(4061,'Fall River','USA','Massachusetts',90555);

select * from CITY;

SELECT ID,NAME,COUNTRYCODE,DISTRICT,POPULATION FROM CITY WHERE COUNTRYCODE = 'USA' AND POPULATION > 100000;
SELECT * FROM CITY WHERE COUNTRYCODE = 'USA' AND POPULATION > 100000;



--Q2. Query the NAME field for all American cities in the CITY table with populations larger than 120000.
--The CountryCode for America is USA.
--The CITY table is described as follows:
SELECT NAME FROM CITY WHERE COUNTRYCODE = 'USA' AND POPULATION > 120000;


--Q3. Query all columns (attributes) for every row in the CITY table.
--The CITY table is described as follows:
select * from CITY;


--Q4. Query all columns for a city in CITY with the ID 1661.
--The CITY table is described as follows:
select * from CITY where ID = 1661;


--Q5. Query all attributes of every Japanese city in the CITY table. The COUNTRYCODE for Japan is JPN.
--The CITY table is described as follows:

SELECT * FROM CITY WHERE COUNTRYCODE = 'JPN';


--Q6. Query the names of all the Japanese cities in the CITY table. The COUNTRYCODE for Japan is JPN.
--The CITY table is described as follows:

SELECT NAME FROM CITY WHERE COUNTRYCODE = 'JPN';



--Q7. Query a list of CITY and STATE from the STATION table.

create table if not exists STATION
(
     ID INT,
     CITY VARCHAR(21),
     STATE VARCHAR(2),
     LAT_N INT,
     LONG_W INT
); 

DESCRIBE STATION;


INSERT INTO STATION VALUES(794,'Kissee Mills','MO',139,73);
INSERT INTO STATION VALUES(824,'Loma Mar','CA',48,130);
INSERT INTO STATION VALUES(603,'Sandy Hook','CT',72,148);
INSERT INTO STATION VALUES(478,'Tipton','IN',33,97);
INSERT INTO STATION VALUES(619,'Arlington','CO',75,92);
INSERT INTO STATION VALUES(711,'Turner','AR',50,101);
INSERT INTO STATION VALUES(839,'Slidell','LA',85,151);
INSERT INTO STATION VALUES(411,'Negreet','LA',98,105);
INSERT INTO STATION VALUES(588,'Glencoe','KY',46,136);
INSERT INTO STATION VALUES(665,'Chelsea','IA',98,59);
INSERT INTO STATION VALUES(342,'Chignik Lagoon','AK',103,153);
INSERT INTO STATION VALUES(733,'Pelahatchie','MS',38,28);
INSERT INTO STATION VALUES(811,'Dorrance','KS',102,121);
INSERT INTO STATION VALUES(698,'Albany','CA',49,80);
INSERT INTO STATION VALUES(325,'Monument','KS',70,141);
INSERT INTO STATION VALUES(414,'Manchester','MD',73,37);
INSERT INTO STATION VALUES(113,'Prescott','IA',39,65);
INSERT INTO STATION VALUES(971,'Graettinger','IA',94,150);
INSERT INTO STATION VALUES(266,'Cahone','CO',116,127);


SELECT * FROM STATION;


SELECT CITY,STATE FROM STATION;


--Q8. Query a list of CITY names from STATION for cities that have an even ID number. Print the results in any order, but exclude duplicates from the answer.
SELECT DISTINCT(CITY) AS City_Name FROM STATION WHERE ID%2 = 0 ORDER BY CITY ASC;


--Q9. Find the difference between the total number of CITY entries in the table and the number of distinct CITY entries in the table.
--For example, if there are three records in the table with CITY values 'New York', 'New York', 'Bengalaru',
--there are 2 different city names: 'New York' and 'Bengalaru'. The query returns , because total number
--of records - number of unique city names = 3-2 =1
SELECT COUNT(CITY) AS TOTAL_NUMBER_OF_RECORDS,COUNT(DISTINCT(CITY)) AS NUMBER_OF_UNIQUE_CITY_NAMES,(COUNT(CITY) - COUNT(DISTINCT(CITY))) AS DIFFERENCE_CITY_COUNT  FROM STATION;


--Q10. Query the two cities in STATION with the shortest and longest CITY names, as well as their respective lengths (i.e.: number of characters in the name). If there is more than one smallest or largest city, choose the one that comes first when ordered alphabetically.

--Sample Input
--For example, CITY has four entries: DEF, ABC, PQRS and WXY.
--Sample Output
--ABC 3
--PQRS 4
--Hint -
--When ordered alphabetically, the CITY names are listed as ABC, DEF, PQRS, and WXY, with lengths and. The longest name is PQRS, but there are options for shortest named city. Choose ABC, because it comes first alphabetically.
--Note
--You can write two separate queries to get the desired output. It need not be a single query.
SELECT CITY,LENGTH(CITY)AS MIN_LENGTH_OF_CITY FROM STATION ORDER BY LENGTH(CITY) ASC LIMIT 1;

SELECT CITY,LENGTH(CITY) AS MAX_LENGTH_OF_CITY FROM STATION ORDER BY LENGTH(CITY) DESC LIMIT 1;


--Q11. Query the list of CITY names starting with vowels (i.e., a, e, i, o, or u) from STATION. Your result cannot contain duplicates.
SELECT DISTINCT(CITY) AS DISTINCT_CITY_NAME FROM STATION WHERE lower(SUBSTR(city,1,1)) in ('a','e','i','o','u');

SELECT DISTINCT CITY FROM STATION
WHERE lcase(CITY) LIKE 'a%'
OR lcase(CITY) LIKE 'e%'
OR lcase(CITY) LIKE 'i%'
OR lcase(CITY) LIKE 'o%'
OR lcase(CITY) LIKE 'u%'
ORDER BY CITY;

--Q12. Query the list of CITY names ending with vowels (a, e, i, o, u) from STATION. Your result cannot contain duplicates.

SELECT DISTINCT CITY FROM STATION
WHERE lcase(CITY) LIKE '%a'
OR lcase(CITY) LIKE '%e'
OR lcase(CITY) LIKE '%i'
OR lcase(CITY) LIKE '%o'
OR lcase(CITY) LIKE '%u'
ORDER BY CITY;



--Q13. Query the list of CITY names from STATION that do not start with vowels. Your result cannot contain duplicates.
SELECT DISTINCT CITY FROM STATION
WHERE lcase(CITY) NOT LIKE 'a%'
AND lcase(CITY) NOT LIKE 'e%'
AND lcase(CITY) NOT LIKE 'i%'
AND lcase(CITY) NOT LIKE 'o%'
AND lcase(CITY) NOT LIKE 'u%'
ORDER BY CITY;


--Q14.Query the list of CITY names from STATION that do not end with vowels. Your result cannot contain duplicates.
SELECT DISTINCT CITY FROM STATION
WHERE lcase(CITY) NOT LIKE '%a'
AND lcase(CITY) NOT LIKE '%e'
AND lcase(CITY) NOT LIKE '%i'
AND lcase(CITY) NOT LIKE '%o'
AND lcase(CITY) NOT LIKE '%u'
ORDER BY CITY;


--Q15. Query the list of CITY names from STATION that either do not start with vowels or do not end with vowels. Your result cannot contain duplicates.

select distinct CITY from STATION where CITY not regexp '^[aeiou]' or city not regexp '[aeiou]$';


--Q16. Query the list of CITY names from STATION that do not start with vowels and do not end with vowels. Your result cannot contain duplicates.
select distinct CITY from STATION where CITY not regexp '^[aeiou]' AND city not regexp '[aeiou]$';


--Q17.
--Table: Product
--product_id is the primary key of this table.
--Each row of this table indicates the name and the price of each product.
create table if not exists Product
(
    product_id int NOT NULL,
    product_name varchar(50),
    unit_price int,
    constraint pk PRIMARY KEY (product_id) 
);


insert into Product values(1,'S8',1000);
insert into Product values(2,'G4',800);
insert into Product values(3,'iPhone',1400);

select * from Product;

--Table: Sales
create table if not exists Sales
(
    seller_id int,
    product_id int,
    buyer_id int,
    sale_date date,
    quantity int,
    price int,
    constraint fk FOREIGN KEY (product_id) REFERENCES  Product(product_id)
);

insert into Sales values(1,1,1,'2019-01-21',2,2000);
insert into Sales values(1,2,2,'2019-02-17',1,800);
insert into Sales values(2,2,3,'2019-06-02',1,800);
insert into Sales values(3,3,4,'2019-05-13',2,2800);

select * from Sales;


--Write an SQL query that reports the products that were only sold in the first quarter of 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.
--Explanation:
--The product with id 1 was only sold in the spring of 2019.
--The product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.
--The product with id 3 was sold after spring 2019.
--We return only product 1 as it is the product that was only sold in the spring of 2019.

SELECT product_id, 
       product_name 
FROM   Product 
WHERE  product_id NOT IN (SELECT product_id 
                          FROM   Sales 
                          WHERE  sale_date NOT BETWEEN 
                                 '2019-01-01' AND '2019-03-31'); 



--Q18.
--Table: Views

create table if not exists Views
(
    article_id int,
    author_id int,
    viewer_id int,
    view_date date
);


insert into Views VALUES (1,3,5,'2019-08-01'), (1,3,6,'2019-08-02'),(2,7,7,'2019-08-01'),(2,7,6,'2019-08-02'), (4,7,1,'2019-07-22'), (3,4,4,'2019-07-21'),(3,4,4,'2019-07-21');

select * from Views;


--There is no primary key for this table, it may have duplicate rows.
--Each row of this table indicates that some viewer viewed an article (written by some author) on some date.
--Note that equal author_id and viewer_id indicate the same person.
--Write an SQL query to find all the authors that viewed at least one of their own articles.
--Return the result table sorted by id in ascending order.
--The query result format is in the following example.

select distinct author_id as id from Views where author_id = viewer_id order by author_id asc;


--Q19.
--Table: Delivery
create table if not exists Delivery
(
    delivery_id int not null,
    customer_id int,
    order_date date,
    customer_pref_delivery_date date,
    constraint pk PRIMARY KEY (delivery_id)
);


insert into Delivery values (1,1,'2019-08-01','2019-08-02'),(2,5,'2019-08-02','2019-08-02'),(3,1,'2019-08-11','2019-08-11'),(4,3,'2019-08-24','2019-08-26'),(5,4,'2019-08-21','2019-08-22'),(6,2,'2019-08-11','2019-08-13');

select * from Delivery;

--The table holds information about food delivery to customers that make orders at some date and
--specify a preferred delivery date (on the same order date or after it).
--If the customer's preferred delivery date is the same as the order date, then the order is called  immediately; otherwise, it is called scheduled.
--Write an SQL query to find the percentage of immediate orders in the table, rounded to 2 decimal places.
--The query result format is in the following example.

select round(100*d2.immediate_orders/count(d1.delivery_id), 2) as immediate_percentage
from Delivery d1,
    (select count(order_date) as immediate_orders
    from Delivery 
    where (order_date = customer_pref_delivery_date)) d2;



--Q20.
--Table: Ads
create table if not exists Ads
(
    ad_id int,
    user_id int,    
    action enum('Clicked', 'Viewed', 'Ignored'),
    constraint pk PRIMARY KEY (ad_id, user_id)   
);

insert into Ads VALUES (1,1,'Clicked'),(2,2,'Clicked'),(3,3,'Viewed'),(5,5,'Ignored'),(1,7,'Ignored'),(2,7,'Viewed'),(3,5,'Clicked'),(1,4,'Viewed'),(2,11,'Viewed'),(1,2,'Clicked');

select * from Ads;


--Write an SQL query to find the ctr of each Ad. Round ctr to two decimal points.
--Return the result table ordered by ctr in descending order and by ad_id in ascending order in case of a tie.

select ad_id,
ifnull(
    round(
        avg(
            case
                when action = "Clicked" then 1
                when action = "Viewed" then 0
                else null
            end
        ) * 100,
    2),
0)
as ctr
from Ads
group by ad_id
order by ctr desc, ad_id asc;



--Q21.
--Table: Employee

create table if not exists Employee
(
    employee_id int,
    team_id int,
    constraint pk PRIMARY KEY (employee_id)
);


insert into Employee VALUES(1,8),(2,8),(3,8),(4,7),(5,9),(6,9);

select * from Employee;

--Write an SQL query to find the team size of each of the employees.
--Return result table in any order.
select employee_id, 
         count(*) over(partition by team_id) as team_size
from Employee order by team_size desc;



--Q22.
--Table: Countries

create table if not exists Countries
(
    country_id int not null,
    country_name varchar(50),
    constraint pk PRIMARY KEY (country_id)
);


insert into Countries VALUES (2,'USA'),(3,'Australia'),(7,'Peru'),(5,'China'),(8,'Morocco'),(9,'Spain');

select * from Countries;

--Table: Weather
create table if not exists Weather
(
    country_id int,
    weather_state int,
    day date,
    constraint pk PRIMARY KEY (country_id, day)
);

insert into Weather VALUES (2,15,'2019-11-01'),(2,12,'2019-10-28'),(2,12,'2019-10-27'),(3,-2,'2019-11-10'),(3,0,'2019-11-11'),(3,3,'2019-11-12'),(5,16,'2019-11-07'),(5,18,'2019-11-09'),(5,21,'2019-11-23'),(7,25,'2019-11-28'),(7,22,'2019-12-01'),(7,20,'2019-12-02'),(8,25,'2019-11-05'),(8,27,'2019-11-15'),(8,31,'2019-11-25'),(9,7,'2019-10-23'),(9,3,'2019-12-23');

select * from Weather;

--Write an SQL query to find the type of weather in each country for November 2019.
--The type of weather is:
--● Cold if the average weather_state is less than or equal 15,
--● Hot if the average weather_state is greater than or equal to 25, and
--● Warm otherwise.
--Return result table in any order.

select c.country_name,
                    case 
                        when AVG(w.weather_state*1.0) <= 15 then 'Cold'
                        when AVG(w.weather_state*1.0) >= 25 then 'Hot'
                        else 'Warm'
                    end as weather_type
from Countries as c
inner JOIN Weather w ON c.country_id = w.country_id 
where w.day between '2019-11-01' and '2019-11-30' 
group by c.country_id;



--Q23.
--Table: Prices
create table if not exists Prices
(
    product_id int,
    start_date date,
    end_date date,
    price int,
    constraint pk PRIMARY KEY (product_id, start_date, end_date)    
);

insert into Prices VALUES (1,'2019-02-17','2019-02-28',5),(1,'2019-03-01','2019-03-22',20),(2,'2019-02-01','2019-02-20',15),(2,'2019-02-21','2019-03-31',30);

select * from Prices;

--Table: UnitsSold
create table if not exists UnitsSold
(
    product_id int,
    purchase_date date,
    units int
);


insert into UnitsSold VALUES (1,'2019-02-25',100),(1,'2019-03-01',15),(2,'2019-02-10',200),(2,'2019-03-22',30);

select * from UnitsSold;

--Write an SQL query to find the average selling price for each product. average_price should be rounded to 2 decimal places.
--Return the result table in any order.


SELECT a.product_id
	, round(SUM(a.units * b.price) / SUM(a.units), 2) AS average_price
FROM UnitsSold a
	JOIN Prices b
	ON (a.product_id = b.product_id
		AND a.purchase_date >= b.start_date
		AND a.purchase_date <= b.end_date)
GROUP BY product_id;

-- select product_id, ifnull(round(sum(prices_sum) / sum(units), 2), 0) as average_price
--     from (
--         select p.product_id as product_id, units, price * units as prices_sum
--             from Prices p left join UnitsSold u
--             on p.product_id = u.product_id and purchase_date between start_date and end_date
--     ) as temp
--     group by product_id;




--Q24.
--Table: Activity
create table if not exists Activity
(
    player_id int,
    device_id int,
    event_date date,
    games_played INT DEFAULT 0,
    constraint pk PRIMARY KEY (player_id, event_date)  
);

INSERT into Activity values (1,2,'2016-03-01',5),(1,2,'2016-05-02',6),(2,3,'2017-06-25',1),(3,1,'2016-03-02',0),(3,4,'2018-07-03',5);


--Write an SQL query to report the first login date for each player.Return the result table in any order.
select player_id,event_date as first_login,
       row_number() over(partition by player_id) as row_num 
from Activity;

select 
     tmp.player_id,tmp.event_date as first_login
from (select *,
        row_number() over(partition by player_id ) as row_num
     from Activity) tmp
where tmp.row_num = 1;


--Q25.
--Table: Activity
--Write an SQL query to report the device that is first logged in for each player.
--Return the result table in any order.
select 
     tmp.player_id,tmp.device_id
from (select *,
        row_number() over(partition by player_id ) as row_num
     from Activity) tmp
where tmp.row_num = 1;


--Q26.
--Table: Products
create table if not exists Products
(
    product_id int,
    product_name VARCHAR(50),
    product_category VARCHAR(50),
    constraint pk PRIMARY KEY (product_id)  
);

insert into Products values (1,'Leetcode Solutions','Book'),(2,'Jewels of Stringology','Book'),(3,'HP','Laptop'),(4,'Lenovo','Laptop'),(5,'Leetcode Kit','T-shirt');

select * from Products;


--Table: Orders
create table if not exists Orders
(
    product_id int,
    order_date date,
    unit int,
    constraint fk FOREIGN KEY (product_id) REFERENCES Products(product_id) 
);

insert into Orders values (1,'2020-02-05',60),(1,'2020-02-10',70),(2,'2020-01-18',30),(2,'2020-02-11',80),(3,'2020-02-17',2),(3,'2020-02-24',3),(4,'2020-03-01',20),(4,'2020-03-04',30),(4,'2020-03-04',60),(5,'2020-02-25',50),(5,'2020-02-27',50),(5,'2020-03-01',50);

select * from Orders;

--Write an SQL query to get the names of products that have at least 100 units ordered in February 2020 and their amount.
--Return result table in any order.
select a.product_name, sum(unit) as unit
from Products a
left join Orders b
on a.product_id = b.product_id
where b.order_date between '2020-02-01' and '2020-02-29'
group by a.product_id
having sum(unit) >= 100;


--Q27.
--Table: Users
create table if not exists Users
(
    user_id int,
    name varchar(50),
    mail varchar(50),
    constraint pk PRIMARY KEY (user_id)
);


insert into Users VALUES (1,'Winston','winston@leetcode.com'),(2,'Jonathan','jonathanisgreat'),(3,'Annabelle','bella-@leetcode.com'),(4,'Sally','sally.come@leetcode.com'),(5,'Marwan','quarz#2020@le
etcode.com'),(6,'David','david69@gmail.com'),(7,'Shapiro','.shapo@leetcode.com');

select * from Users;

--Write an SQL query to find the users who have valid emails.
--A valid e-mail has a prefix name and a domain where:
--● The prefix name is a string that may contain letters (upper or lower case), digits, underscore
--'_', period '.', and/or dash '-'. The prefix name must start with a letter.
--● The domain is '@leetcode.com'.
--Return the result table in any order.

SELECT *
FROM Users
WHERE REGEXP_LIKE(mail, '^[a-zA-Z][a-zA-Z0-9\_\.\-]*@leetcode.com');


--Q28.
--Table: Customers
create table if not exists Customers
(
    customer_id int,
    name varchar(50),
    country varchar(50),
    constraint pk PRIMARY KEY (customer_id)
);


insert into Customers VALUES (1,'Winston','USA'),(2,'Jonathan','Peru'),(3,'Moustafa','Egypt');

select * from Customers;


--Table: Product
create table if not exists Product
(
    product_id int,
    description varchar(255),
    price int,
    constraint pk PRIMARY KEY (product_id)
);

insert into Product values (10,'LC Phone',300),(20,'LC T-Shirt',10),(30,'LC Book',45),(40,'LC Keychain',2);

select * from Product;

--Table: Orders
create table if not exists Orders
(
    order_id int,
    customer_id int,
    product_id int,
    order_date DATE,
    quantity int,
    constraint pk PRIMARY KEY (order_id)
    -- constraint fk FOREIGN KEY (customer_id) REFERENCES Customers(customer_id),
    -- constraint fk FOREIGN KEY (product_id) REFERENCES Product(product_id)
);

 

insert into Orders VALUES (1,1,10,'2020-06-10',1),(2,1,20,'2020-07-01',1),(3,1,30,'2020-07-08',2),(4,2,10,'2020-06-15',2),(5,2,40,'2020-07-01',10),(6,3,20,'2020-06-24',2),(7,3,30,'2020-06-25',2),(9,3,30,'2020-05-08',3);

select * from Orders;


--Write an SQL query to report the customer_id and customer_name of customers who have spent at
--least $100 in each month of June and July 2020.
--Return the result table in any order.
select o.customer_id, c.name
from Customers c, Product p, Orders o
where c.customer_id = o.customer_id and p.product_id = o.product_id
group by o.customer_id
having 
(
    sum(case when o.order_date like '2020-06%' then o.quantity*p.price else 0 end) >= 100
    and
    sum(case when o.order_date like '2020-07%' then o.quantity*p.price else 0 end) >= 100
);



--Q29.
--Table: TVProgram
create table if not exists TVProgram
(
    program_date date,
    content_id int,
    channel varchar(50),
    constraint pk PRIMARY KEY (program_date, content_id)
);

insert into TVProgram VALUES ('2020-06-10 08:00',1,'LC-Channel'),('2020-05-11 12:00',2,'LC-Channel'),('2020-05-12 12:00',3,'LC-Channel'),('2020-05-13 14:00',4,'Disney Ch'),('2020-06-18 14:00',4,'Disney Ch'),('2020-07-15 16:00',5,'Disney Ch');

select * from TVProgram;

--Table: Content
create table if not exists Content
(
    content_id varchar(50),
    title varchar(50),
    Kids_content enum('Y','N'),
    content_type varchar(50),
    constraint pk PRIMARY KEY (content_id)
);

insert into Content VALUES (1,'Leetcode Movie','N','Movies'),(2,'Alg. for Kids','Y','Series'),(3,'Database Sols','N','Series'),(4,'Aladdin','Y','Movies'),(5,'Cinderella','Y','Movies');
select * from Content;

--Write an SQL query to report the distinct titles of the kid-friendly movies streamed in June 2020.
--Return the result table in any order.

SELECT DISTINCT title
FROM Content ctt
INNER JOIN TVProgram tv
ON ctt.content_id = tv.content_id
WHERE content_type = 'Movies'
AND Kids_content = 'Y'
AND program_date BETWEEN '2020-06-01' AND '2020-06-30';

--Q30.
--Table: NPV
create table if not exists NPV
(
    id int,
    year int,
    npv int,
    constraint pk PRIMARY KEY (id, year)
);

insert into NPV VALUES (1,2018,100),(7,2020,30),(13,2019,40),(1,2019,113),(2,2008,121),(3,2009,12),(11,2020,99),(7,2019,0);

select * from NPV;

--Table: Queries
create table if not exists Queries
(
    id int,
    year int,
    constraint pk PRIMARY KEY (id, year)
);

insert into Queries VALUES (1, 2019),(2,2008),(3,2009),(7,2018),(7,2019),(7,2020),(13,2019);

select * from Queries;

--Write an SQL query to find the npv of each query of the Queries table.
--Return the result table in any order.
SELECT q.id, q.year, COALESCE(n.npv,0) AS npv
FROM Queries q
LEFT JOIN NPV n
ON q.id = n.id AND q.year=n.year;


--Q32.
--Table: Employees
create table if not exists Employees
(
    id int,
    name varchar(50),
    constraint pk PRIMARY KEY (id)
);

insert into Employees VALUES (1,'Alice'),(7,'Bob'),(11,'Meir'),(90,'Winston'),(3,'Jonathan');

select * from Employees;

--Table: EmployeeUNI
create table if not exists EmployeeUNI
(
    id int,
    unique_id int,
    constraint pk PRIMARY KEY (id, unique_id)
);

insert into EmployeeUNI VALUES (3,1),(11,2),(90,3);
select * from EmployeeUNI;


--Write an SQL query to show the unique ID of each user, If a user does not have a unique ID replace just show null.
--Return the result table in any order.
select unique_id, name
from Employees
left join EmployeeUNI
on if (Employees.id = EmployeeUNI.id, Employees.id, null);


--Q33.
--Table: Users
create table if not exists Users
(
    id int,
    name VARCHAR(50),
    constraint pk PRIMARY KEY (id)
);

insert into Users VALUES (1,'Alice'),(2,'Bob'),(3,'Alex'),(4,'Donald'),(7,'Lee'),(13,'Jonathan'),(19,'Elvis');

select * from Users;

--Table: Rides
create table if not exists Rides
(
    id int,
    user_id int,
    distance int,
    constraint pk PRIMARY KEY (id),
    constraint fk FOREIGN KEY (user_id) REFERENCES Users(id)
);

insert into Rides VALUES (1,1,120),(2,2,317),(3,3,222),(4,7,100),(5,13,312),(6,19,50),(7,7,120),(8,19,400),(9,7,230);

select * from Rides;

--Write an SQL query to report the distance travelled by each user.
--Return the result table ordered by travelled_distance in descending order, if two or more users travelled the same distance, order them by their name in ascending order.
select name, sum(ifnull(distance, 0)) as travelled_distance
from Rides r
right join Users u
on r.user_id = u.id
group by name
order by 2 desc,1 asc;


--Q34.
--Table: Products
create table if not exists Products
(
    product_id int,
    product_name varchar(50),
    product_category VARCHAR(50),
    constraint pk PRIMARY KEY (product_id)
);

insert into Products VALUES (1,'Leetcode Solutions','Book'),(2,'Jewels of Stringology','Book'),(3,'HP','Laptop'),(4,'Lenovo','Laptop'),(5,'Leetcode Kit','T-shirt');

select * from Products;

--Table: Orders
create table if not exists Orders
(
    product_id int,
    order_date date,
    unit int
);

insert into Orders values (1,'2020-02-05',60),(1,'2020-02-10',70),(2,'2020-01-18',30),(2,'2020-02-11',80),(3,'2020-02-17',2),(3,'2020-02-24',3),(4,'2020-03-01',20),(4,'2020-03-04',30),(4,'2020-03-04',60),(5,'2020-02-25',50),(5,'2020-02-27',50),(5,'2020-03-01',50);

select * from Orders;

--Write an SQL query to get the names of products that have at least 100 units ordered in February 2020 and their amount.
--Return result table in any order.
select a.product_name, sum(unit) as unit
from Products a
left join Orders b
on a.product_id = b.product_id
where b.order_date between '2020-02-01' and '2020-02-29'
group by a.product_id
having sum(unit) >= 100;


--Q35.
--Table: Movies
create table if not exists Movies
(
    movie_id int,
    title varchar(50),
    constraint pk PRIMARY KEY (movie_id)
);

insert into Movies VALUES (1,'Avengers'),(2,'Frozen 2'),(3,'Joker');
select * from Movies;

--Table: Users
create table if not exists Users
(
    user_id int,
    name varchar(50),
    constraint pk PRIMARY KEY (user_id)
);

insert into Users VALUES (1,'Daniel'),(2,'Monica'),(3,'Maria'),(4,'James');
select * from Users;

--MovieRating table:
create table if not exists MovieRating
(
    movie_id int,
    user_id int,
    rating int,
    created_at date,
    constraint pk PRIMARY KEY (movie_id, user_id)
);

insert into MovieRating VALUES (1,1,3,'2020-01-12'),(1,2,4,'2020-02-11'),(1,3,2,'2020-02-12'),(1,4,1,'2020-01-01'),(2,1,5,'2020-02-17'),(2,2,2,'2020-02-01'),(2,3,2,'2020-03-01'),(3,1,3,'2020-02-22'),(3,2,4,'2020-02-25');
select * from MovieRating;

--Write an SQL query to:
--● Find the name of the user who has rated the greatest number of movies. In case of a tie,
--return the lexicographically smaller user name.
--● Find the movie name with the highest average rating in February 2020. In case of a tie, return
--the lexicographically smaller movie name.

SELECT user_name AS results FROM
(
SELECT a.name AS user_name, COUNT(*) AS counts FROM MovieRating AS b
    JOIN Users AS a
    on a.user_id = b.user_id
    GROUP BY b.user_id
    ORDER BY counts DESC, user_name ASC LIMIT 1
) first_query
UNION
SELECT movie_name AS results FROM
(
SELECT c.title AS movie_name, AVG(d.rating) AS rate FROM MovieRating AS d
    JOIN Movies AS c
    on c.movie_id = d.movie_id
    WHERE substr(d.created_at, 1, 7) = '2020-02'
    GROUP BY d.movie_id
    ORDER BY rate DESC, movie_name ASC LIMIT 1
) second_query;



--Q36.Table: Users
create table if not exists Users
(
    id int,
    name varchar(50),
    constraint pk PRIMARY KEY (id)
);

insert into Users VALUES (1,'Alice'),(2,'Bob'),(3,'Alex'),(4,'Donald'),(7,'Lee'),(13,'Jonathan'),(19,'Elvis');

select * from Users;


--Table: Rides
create table if not exists Rides
(
    id int,
    user_id int,
    distance int,
    constraint pk PRIMARY KEY (id),
    constraint fk FOREIGN KEY (user_id) REFERENCES Users(id)
);

insert into Rides VALUES (1,1,120),(2,2,317),(3,3,222),(4,7,100),(5,13,312),(6,19,50),(7,7,120),(8,19,400),(9,7,230);

select * from Rides;

--Write an SQL query to report the distance travelled by each user.
--Return the result table ordered by travelled_distance in descending order, if two or more users
--travelled the same distance, order them by their name in ascending order.
select name, sum(ifnull(distance, 0)) as travelled_distance
from Rides r
right join Users u
on r.user_id = u.id
group by name
order by 2 desc,1 asc;




--Q37.
--Table: Employees
create table if not exists Employees
(
    id int,
    name varchar(50),
    constraint pk PRIMARY KEY (id)
);

insert into Employees VALUES (1,'Alice'),(7,'Bob'),(11,'Meir'),(90,'Winston'),(3,'Jonathan');

select * from Employees;

--Table: EmployeeUNI
create table if not exists EmployeeUNI
(
    id int,
    unique_id int,
    constraint pk PRIMARY KEY (id, unique_id)
);

insert into EmployeeUNI VALUES (3,1),(11,2),(90,3);
select * from EmployeeUNI;


--Write an SQL query to show the unique ID of each user, If a user does not have a unique ID replace just show null.
--Return the result table in any order.
select unique_id, name
from Employees
left join EmployeeUNI
on if (Employees.id = EmployeeUNI.id, Employees.id, null);


--Q38.
--Table: Departments
create table if not exists Departments
(
    id int,
    name varchar(50),
    constraint pk PRIMARY KEY (id)
);

insert into Departments VALUES (1,'Electrical Engineering'),(7,'Computer Engineering'),(13,'Business Administration');

select * from Departments;

--Table: Students
create table if not exists Students
(
    id int,
    name varchar(50),
    department_id int,
    constraint pk PRIMARY KEY (id)
);

insert into Students VALUES (23,'Alice',1),(1,'Bob',7),(5,'Jennifer',13),(2,'John',14),(4,'Jasmine',77),(3,'Steve',74),(6,'Luis',1),(8,'Jonathan',7),(7,'Daiana',33),(11,'Madelynn',1);

select * from Students;

--Write an SQL query to find the id and the name of all students who are enrolled in departments that no longer exist.
--Return the result table in any order.
select s.id, s.name
from Students s
left join Departments d
on s.department_id = d.id
where d.id is null;


--Q39.
--Table: Calls
create table if not exists Calls
(
    from_id int,
    to_id int,
    duration int
);

insert into Calls VALUES (1,2,59),(2,1,11),(1,3,20),(3,4,100),(3,4,200),(3,4,200),(4,3,499);

select * from Calls;

--Write an SQL query to report the number of calls and the total call duration between each pair of distinct persons (person1, person2) where person1 < person2.
--Return the result table in any order.

SELECT LEAST(from_id,to_id) as person1,
GREATEST(from_id,to_id) as person2,
COUNT(*) as call_count,
SUM(duration) as total_duration
FROM Calls
GROUP BY person1,person2;


--Q40.
--Table: Prices
create table if not exists Prices
(
    product_id int,
    start_date date,
    end_date date,
    price int,
    constraint pk PRIMARY KEY (product_id, start_date, end_date)
);

insert into Prices VALUES (1,'2019-02-17','2019-02-28',5), (1,'2019-03-01','2019-03-22',20), (2,'2019-02-01','2019-02-20',15), (2,'2019-02-21','2019-03-31',30);

select * from Prices;

--UnitsSold table:
create table if not exists UnitsSold
(
    product_id int,
    purchase_date date,
    units int
);

insert into UnitsSold VALUES (1,'2019-02-25',100),(1,'2019-03-01',15),(2,'2019-02-10',200),(2,'2019-03-22',30);

select * from UnitsSold;


--Write an SQL query to find the average selling price for each product. average_price should be rounded to 2 decimal places.
--Return the result table in any order.
select p.product_id, 
    round(sum(p.price * u.units)/sum(u.units), 2) as average_price
from Prices p
left join UnitsSold u
on p.product_id = u.product_id and 
    datediff(u.purchase_date, p.start_date) >= 0 and
    datediff(p.end_date, u.purchase_date) >= 0
group by p.product_id;



--Q41.
--Table: Warehouse
create table if not exists Warehouse
(
    name VARCHAR(50),
    product_id int,
    units int,
    constraint pk PRIMARY KEY (name, product_id)
);

insert into Warehouse VALUES ('LCHouse1',1,1),('LCHouse1',2,10),('LCHouse1',3,5),('LCHouse2',1,2),('LCHouse2',2,2),('LCHouse3',4,1);
select * from Warehouse;

--Table: Products
create table if not exists Products
(
    product_id int,
    product_name VARCHAR(50),
    Width int,
    Length int,
    Height int,
    constraint pk PRIMARY KEY (product_id)
);

insert into Products VALUES (1,'LC-TV',5,50,40),(2,'LC-KeyChain',5,5,5),(3,'LC-Phone',2,10,10),(4,'LC-T-Shirt',4,10,20);

select * from Products;

--Write an SQL query to report the number of cubic feet of volume the inventory occupies in each warehouse.
--Return the result table in any order.
select name as warehouse_name, sum(units * vol) as volume
from Warehouse w
join (select product_id, Width*Length*Height as vol
     from Products) p
on w.product_id = p.product_id
group by name;


--Q42.
--Table: Sales
create table if not exists Sales
(
    sale_date date,
    fruit enum("apples","oranges"),
    sold_num int,
    constraint pk PRIMARY KEY (sale_date, fruit)
);

insert into Sales VALUES ('2020-05-01','apples',10),('2020-05-01','oranges',8),('2020-05-02','apples',15),('2020-05-02','oranges',15),('2020-05-03','apples',20),('2020-05-03','oranges',0),('2020-05-04','apples',15),('2020-05-04','oranges',16);

select * from Sales;

--Write an SQL query to report the difference between the number of apples and oranges sold each day.
--Return the result table ordered by sale_date.

select a.sale_date, (a.sold_num - b.sold_num) as diff 
from Sales a left join Sales b
on a.sale_date = b.sale_date
where a.fruit = 'apples' and b.fruit = 'oranges';


--Q43.
--Table: Activity
create table if not exists Activity
(
    player_id int,
    device_id int,
    event_date date,
    games_played int,
    constraint pk PRIMARY KEY (player_id, event_date)
);

insert into Activity VALUES (1,2,'2016-03-01',5),(1,2,'2016-03-02',6),(2,3,'2017-06-25',1),(3,1,'2016-03-02',0),(3,4,'2018-07-03',5);

select * from Activity;

--Write an SQL query to report the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of players.
WITH CTE AS (
SELECT
player_id, min(event_date) as event_start_date
from
Activity
group by player_id )

SELECT
round((count(distinct c.player_id) / (select count(distinct player_id) from Activity)),2)as fraction
FROM
CTE c
JOIN Activity a
on c.player_id = a.player_id
and datediff(c.event_start_date, a.event_date) = -1;


--Q44.
--Table: Employee
create table if not exists Employee
(
    id int,
    name VARCHAR(50),
    department VARCHAR(50),
    managerId int default null,
    constraint pk PRIMARY KEY (id)
);


insert into Employee VALUES (101,'John','A',null), (102,'Dan','A',101), (103,'James','A',101), (104,'Amy','A',101), (105,'Anne','A',101), (106,'Ron','B',101);

select * from Employee;

--Write an SQL query to report the managers with at least five direct reports.
--Return the result table in any order.
select 
    a.name 
from 
    Employee a 
inner join 
    Employee b 
on (a.id = b.managerid) 
group by a.name 
having count(distinct b.id) >= 5;

-- select Name from Employee
-- where Id in
-- (
--   select ManagerId from Employee
--   group by 1
--   having count(*) >= 5
-- );


--Q45.

--Table: Department
create table if not exists Department
(
    dept_id int,
    dept_name VARCHAR(50),
    constraint pk PRIMARY KEY (dept_id)
);


insert into Department VALUES (1,'Engineering'),(2,'Science'),(3,'Law');

select * from Department;

--Table: Student
create table if not exists Student
(
    student_id int,
    student_name VARCHAR(50),
    gender VARCHAR(50),
    dept_id int,
    constraint pk PRIMARY KEY (student_id),
    constraint fk FOREIGN KEY (dept_id) REFERENCES Department(dept_id)
);

insert into Student VALUES (1,'Jack','M',1),(2,'Jane','F',1),(3,'Mark','M',2);

select * from Student;


--Write an SQL query to report the respective department name and number of students majoring in each department for all departments in the Department table (even ones with no current students).
--Return the result table ordered by student_number in descending order. In case of a tie, order them by dept_name alphabetically.
select 
    a.dept_name,
    coalesce(count(student_id), 0) student_number
from 
    Department a 
left join
    Student b
on 
    (a.dept_id = b.dept_id)
group by a.dept_name
order by student_number desc, a.dept_name asc;


--Q46.
--Table: Product
create table if not exists Product
(
    product_key int,
    constraint pk PRIMARY KEY (product_key)
);

insert into Product VALUES (5),(6);

select * from Product;

--Table: Customer
create table if not exists Customer
(
    customer_id int,
    product_key int,
    constraint fk FOREIGN KEY (product_key) REFERENCES Product(product_key)
);


insert into Customer VALUES (1,5),(2,6),(3,5),(3,6),(1,6);

select * from Customer;

--Write an SQL query to report the customer ids from the Customer table that bought all the products in the Product table.
--Return the result table in any order.
SELECT
    customer_id
FROM customer
GROUP BY customer_id
HAVING COUNT( DISTINCT product_key) = (SELECT COUNT(*) FROM product);


--Q47.
--Table: Employee
create table if not exists Employee
(
    employee_id int,
    name VARCHAR(50),
    experience_years int,
    constraint pk PRIMARY KEY (employee_id)
);

insert into Employee VALUES (1,'Khaled',3),(2,'Ali',2),(3,'John',3),(4,'Doe',2);

select * from Employee;

--Table: Project
create table if not exists Project
(
    project_id int,
    employee_id int,
    constraint pk PRIMARY KEY (project_id, employee_id),
    constraint fk FOREIGN KEY (employee_id) REFERENCES Employee(employee_id)

);

insert into Project VALUES (1,1),(1,2),(1,3),(2,1),(2,4);

select * from Project;

--Write an SQL query that reports the most experienced employees in each project. In case of a tie, report all employees with the maximum number of experience years.
--Return the result table in any order.
SELECT
    project_id,
    employee_id
FROM (
    SELECT
        p.project_id,
        p.employee_id,
        DENSE_RANK() OVER(PARTITION BY p.project_id ORDER BY e.experience_years DESC) as rnk
    FROM Project as p JOIN Employee as e
    ON p.employee_id = e.employee_id
    ) x
WHERE rnk = 1;


--Q48.
--Table: Books
create table if not exists Books
(
    book_id int,
    name VARCHAR(50),
    available_from date,
    constraint pk PRIMARY KEY (book_id)
);

insert into Books VALUES (1,'"Kalila And Demna"','2010-01-01'),(2,'"28 Letters"','2012-05-12'),(3,'"The Hobbit"','2019-06-10'),(4,'"13 Reasons Why"','2010-01-01'),(5,'"The Hunger Games"','2008-09-21');

select * from Books;

--Table: Orders
create table if not exists Orders
(
    order_id int,
    book_id int,
    quantity int,
    dispatch_date date,
    constraint pk PRIMARY KEY (order_id),
    constraint fk FOREIGN KEY (book_id) REFERENCES Books(book_id)
);

insert into Orders VALUES (1,1,2,'2018-07-26'),(2,1,1,'2018-11-05'),(3,3,8,'2019-06-11'),(4,4,6,'2019-06-05'),(5,4,5,'2019-06-20'),(6,5,9,'2009-02-02'),(7,5,8,'2010-04-13');


select * from Orders;
--Write an SQL query that reports the books that have sold less than 10 copies in the last year, excluding books that have been available for less than one month from today. Assume today is 2019-06-23.
--Return the result table in any order.

select Books.book_id, name from Books join Orders
    on Books.book_id = Orders.book_id
    where available_from < '2019-05-23'
    and dispatch_date between '2018-06-23' and '2019-06-23'
    group by Books.book_id
    having sum(quantity) < 10
    union
select book_id, name from Books
    where available_from < '2019-05-23'
    and book_id not in (
        select distinct book_id from Orders where dispatch_date between '2018-06-23' and '2019-06-23'
    );


--Q49.
--Table: Enrollments
create table if not exists Enrollments
(
    student_id int,
    course_id int,
    grade int,
    constraint pk PRIMARY KEY (student_id, course_id)
);

insert into Enrollments VALUES (2,2,95),(2,3,95),(1,1,90),(1,2,99),(3,1,80),(3,2,75),(3,3,82);

select * from Enrollments;

--Write a SQL query to find the highest grade with its corresponding course for each student. In case of a tie, you should find the course with the smallest course_id.
--Return the result table ordered by student_id in ascending order.
select e.student_id, e.course_id, e.grade
from (
  select *, row_number() over (partition by student_id order by grade desc) rn
  from Enrollments
) e
where e.rn = 1;


--Q50.
--Table: Teams

--Players table:
create table if not exists Players
(
    player_id int,
    group_id int,
    constraint pk PRIMARY KEY (player_id)
);

insert into Players VALUES (15,1), (25,1), (30,1), (45,1), (10,2), (35,2), (50,2), (20,3), (40,3);

select * from Players;

--Table: Matches
create table if not exists Matches
(
    match_id int,
    first_player int,
    second_player int,
    first_score int,
    second_score int,
    constraint pk PRIMARY KEY (match_id)
);

insert into Matches VALUES (1,15,45,3,0),(2,30,25,1,2),(3,30,15,2,0),(4,40,20,5,2),(5,35,50,1,1);

select * from Matches;

--Write an SQL query to find the winner in each group.
--Return the result table in any order.
select group_id,player_id from 
(select group_id,player_id,sum((
    case when player_id = first_player then first_score
         when player_id = second_player then second_score
         end
)) as totalScores
from Players p,Matches m
where p.player_id = m.first_player
or p.player_id = m.second_player
group by group_id,player_id
order by group_id,totalScores desc,player_id) as temp
group by group_id
order by group_id,totalScores desc,player_id;

--Q51.
--World table:
create table if not exists World
(
    name VARCHAR(50),
    continent varchar(50),
    area int,
    population bigint,
    gdp bigint,
    constraint pk PRIMARY KEY (name)
);

insert into World VALUES ('Afghanistan','Asia',652230,25500100,20343000000),('Albania','Europe',28748,2831741,12960000000),('Algeria','Africa',2381741,37100000,188681000000),('Andorra','Europe',468,78115,3712000000),('Angola','Africa',1246700,20609294,100990000000);

select * from World;

--Write an SQL query to report the name, population, and area of the big countries.
--Return the result table in any order.
SELECT name,population,area
FROM World
WHERE area > 3000000 or population > 25000000;


--Q52.
--Table: Customer
create table if not exists Customer
(
    id int,
    name varchar(50),
    referee_id int,
    constraint pk PRIMARY KEY (id)
);

insert into Customer VALUES (1,'Will',null),(2,'Jane',null),(3,'Alex',2),(4,'Bill',null),(5,'Zack',1),(6,'Mark',2);
select * from Customer;

--Write an SQL query to report the names of the customer that are not referred by the customer with id= 2.
--Return the result table in any order.
select name from Customer where referee_id != 2 or referee_id is null;


--Q53.
--Table: Customers
create table if not exists Customers
(
    id int,
    name varchar(50),
    constraint pk PRIMARY KEY (id)
);

insert into Customers VALUES (1,'Joe'),(2,'Henry'),(3,'Sam'),(4,'Max');

select * from Customers;

--Table: Orders
create table if not exists Orders
(
    id int,
    customerId int,
    constraint pk PRIMARY KEY (id),
    constraint fk FOREIGN KEY (customerId) REFERENCES Customers(id)
);

insert into Orders VALUES (1,3),(2,1);

select * from Orders;

--Write an SQL query to report all customers who never order anything.
--Return the result table in any order.
SELECT C.Name FROM Customers C LEFT JOIN Orders O ON C.Id = O.CustomerId WHERE O.CustomerId is NULL;


--Q54.
--Table: Employee
create table if not exists Employee
(
    employee_id int,
    team_id int,
    constraint pk PRIMARY KEY (employee_id)
);

insert into Employee VALUES (1,8),(2,8),(3,8),(4,7),(5,9),(6,9);

select * from Employee;

--Write an SQL query to find the team size of each of the employees.
--Return result table in any order.
SELECT employee_id, COUNT(team_id) OVER (PARTITION BY team_id) team_size
FROM Employee;


--Q55
--Table Person:
create table if not exists Person
(
    id int,
    name VARCHAR(50),
    phone_number VARCHAR(50),
    constraint pk PRIMARY KEY (id)
);

insert into Person VALUES (3,'Jonathan','051-1234567'),(12,'Elvis','051-7654321'),(1,'Moncef','212-1234567'),(2,'Maroua','212-6523651'),(7,'Meir','972-1234567'),(9,'Rachel','972-0011100');

select * from Person;

--Country table:
create table if not exists Country
(
    name VARCHAR(50),
    country_code VARCHAR(50),
    constraint pk PRIMARY KEY (country_code)
);

insert into Country VALUES ('Peru',51),('Israel',972),('Morocco',212),('Germany',49),('Ethiopia',251);

select * from Country;

--Table Calls:
create table if not exists Calls
(
    caller_id int,
    callee_id int,
    duration int
);

insert into Calls VALUES (1,9,33),(2,9,4),(1,2,59),(3,12,102),(3,12,330),(12,3,5),(7,9,13),(7,1,3),(9,7,1),(1,7,7);

select * from Calls;

--Write an SQL query to find the countries where this company can invest.
--Return the result table in any order.

SELECT
 co.name AS country
FROM
 Person p
 JOIN
     Country co
     ON SUBSTRING(phone_number,1,3) = country_code
 JOIN
     Calls c
     ON p.id IN (c.caller_id, c.callee_id)
GROUP BY
 co.name
HAVING
 AVG(duration) > (SELECT AVG(duration) FROM Calls);



--Q56.
--Table: Activity
create table if not exists Activity
(
    player_id int,
    device_id int,
    event_date date,
    games_played int,
    constraint pk PRIMARY KEY (player_id, event_date)
);

insert into Activity VALUES (1,2,'2016-03-01',5),(1,2,'2016-05-02',6),(2,3,'2017-06-25',1),(3,1,'2016-03-02',0),(3,4,'2018-07-03',5);

select * from Activity;

--Write an SQL query to report the device that is first logged in for each player.
--Return the result table in any order
select player_id, min(event_date) as first_login
from Activity 
group by player_id;


--Q57.
--Table: Orders
create table if not exists Orders
(
    order_number int,
    customer_number int,
    constraint pk PRIMARY KEY (order_number)
);

insert into Orders VALUES (1,1),(2,2),(3,3),(4,3);

select * from Orders;

--Write an SQL query to find the customer_number for the customer who has placed the largest number of orders.
--The test cases are generated so that exactly one customer will have placed more orders than any other customer.
SELECT
    customer_number
FROM
    Orders
GROUP BY customer_number
ORDER BY COUNT(*) DESC
LIMIT 1
;


--Q58.
--Table: Cinema
create table if not exists Cinema
(
    seat_id int AUTO_INCREMENT,
    free bool,
    constraint pk PRIMARY KEY (seat_id)
);

insert into Cinema VALUES (1,1),(2,0),(3,1),(4,1),(5,1);

select * from Cinema;

--Write an SQL query to report all the consecutive available seats in the cinema.
--Return the result table ordered by seat_id in ascending order.
SELECT
    DISTINCT t1.seat_id
FROM Cinema AS t1 JOIN Cinema AS t2
ON abs(t1.seat_id - t2.seat_id) = 1
AND t1.free = 1 AND t2.free = 1
ORDER BY 1; 


--Q59.
--Table: SalesPerson
create table if not exists SalesPerson
(
    sales_id int,
    name VARCHAR(50),
    salary int,
    commission_rate int,
    hire_date date,
    constraint pk PRIMARY KEY (sales_id)
);

INSERT into SalesPerson VALUES (1,'John',100000,6,'4/1/2006'),(2,'Amy',12000,5,'5/1/2010'),(3,'Mark',65000,12,'12/25/2008'),(4,'Pam',25000,25,'1/1/2005'),(5,'Alex',5000,10,'2/3/2007');


select * from SalesPerson;


--Table: Company
create table if not exists Company
(
    com_id int,
    name VARCHAR(50),
    city VARCHAR(50),
    constraint pk PRIMARY KEY (com_id)
);

insert into Company VALUES (1,'RED','Boston'),(2,'ORANGE','New York'),(3,'YELLOW','Boston'),(4,'GREEN','Austin');

select * from Company;

--Table: Orders
create table if not exists Orders
(
    order_id int,
    order_date DATE,
    com_id int,
    sales_id int,
    amount int,
    constraint pk PRIMARY KEY (order_id),
    constraint fk FOREIGN KEY (com_id) REFERENCES Company(com_id),
    constraint fk FOREIGN KEY (sales_id) REFERENCES SalesPerson(sales_id)
);


insert into Orders VALUES (1,'1/1/2014',3,4,10000),(2,'2/1/2014',4,5,5000),(3,'3/1/2014',1,1,50000),(4,'4/1/2014',1,4,25000);

select * from Orders;


--Write an SQL query to report the names of all the salespersons who did not have any orders related to the company with the name "RED".
--Return the result table in any order.
SELECT name
FROM Salesperson
WHERE sales_id
NOT IN (
    SELECT s.sales_id FROM Orders o
    INNER JOIN Salesperson s ON o.sales_id = s.sales_id
    INNER JOIN Company c ON o.com_id = c.com_id
    WHERE c.name = 'RED'
);


--Q60.
--Table: Triangle
create table if not exists Triangle
(
    x int,
    y int,
    z int,
    constraint pk PRIMARY KEY (x,y,z)
);

insert into Triangle VALUES (13,15,30),(10,20,15);

select * from Triangle;

--Write an SQL query to report for every three line segments whether they can form a triangle.
--Return the result table in any order.

SELECT
    x,
    y,
    z,
    CASE WHEN x + y > z AND y + z > x AND z + x > y THEN 'Yes'
        ELSE 'No' END AS triangle
FROM Triangle;


--Q61.
--Table: Point
create table if not exists Point
(
    x int,
    constraint pk PRIMARY KEY (x)
);

insert into Point VALUES (-1),(0),(2);

select * from Point;

--Write an SQL query to report the shortest distance between any two points from the Point table.
--The query result format is in the following example.
select min(abs(p2.x-p1.x)) as shortest
from Point p1, Point p2
where p1.x != p2.x;


--Q62.
--Table: ActorDirector
create table if not exists ActorDirector
(
    actor_id int,
    director_id int,
    timestamp int,
    constraint pk PRIMARY KEY (timestamp)
);


insert into ActorDirector VALUES (1,1,0),(1,1,1),(1,1,2),(1,2,3),(1,2,4),(2,1,5),(2,1,6);

select * from ActorDirector;

--Write a SQL query for a report that provides the pairs (actor_id, director_id) where the actor has cooperated with the director at least three times.
--Return the result table in any order.
SELECT actor_id, director_id
FROM ActorDirector
GROUP BY actor_id, director_id
HAVING COUNT(*) >= 3;


--Q63.

--Table: Product
create table if not exists Product
(
    product_id int,
    product_name varchar(50),
    constraint pk PRIMARY KEY (product_id)
);

insert into Product VALUES (100,'Nokia'),(200,'Apple'),(300,'Samsung');

select * from Product;

--Table: Sales
create table if not exists Sales
(
    sale_id int,
    product_id int,
    year int,
    quantity int,
    price int,
    constraint pk PRIMARY KEY (sale_id, year),
    constraint fk FOREIGN KEY (product_id) REFERENCES Product(product_id)
);

insert into Sales VALUES (1,100,2008,10,5000),(2,100,2009,12,5000),(7,200,2011,15,9000);

select * from Sales;

--Write an SQL query that reports the product_name, year, and price for each sale_id in the Sales table.
--Return the resulting table in any order.
select p.product_name, s.year, s.price
from Product p
join Sales s
on s.product_id = p.product_id;

--Q64.
--Table: Employee
create table if not exists Employee
(
    employee_id int,
    name varchar(50),
    experience_years int,
    constraint pk PRIMARY KEY (employee_id)
);

insert into Employee VALUES (1,'Khaled',3),(2,'Ali',2),(3,'John',1),(4,'Doe',2);

select * from Employee;

--Table: Project
create table if not exists Project
(
    project_id int,
    employee_id int,
    constraint pk PRIMARY KEY (project_id, employee_id),
    constraint fk FOREIGN KEY (employee_id) REFERENCES Employee(employee_id)

);

insert into Project VALUES (1,1),(1,2),(1,3),(2,1),(2,4);

select * from Project;

--Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.
--Return the result table in any order.
select project_id , round(avg(experience_years), 2) as average_years
from Project as p
left join Employee as e
on p.employee_id = e.employee_id
group by project_id;



--Q65.
--Table: Product
create table if not exists Product
(
    product_id int,
    product_name VARCHAR(50),
    unit_price int,
    constraint pk PRIMARY KEY (product_id)
);

insert into Product VALUES (1,'S8',1000),(2,'G4',800),(3,'iPhone',1400);

--Table: Sales
create table if not exists Sales
(
    seller_id int,
    product_id int,
    buyer_id int,
    sale_date date,
    quantity int,
    price int,
    constraint fk FOREIGN KEY (product_id) REFERENCES Product(product_id)
);

insert into Sales VALUES (1,1,1,'2019-01-21',2,2000),(1,2,2,'2019-02-17',1,800),(2,2,3,'2019-06-02',1,800),(3,3,4,'2019-05-13',2,2800);

select * from Sales;

--Write an SQL query that reports the best seller by total sales price, If there is a tie, report them all.
--Return the result table in any order.
select a.seller_id
from 
(select seller_id, sum(price) as sum 
from Sales
group by seller_id) a 
where a.sum = (select max(b.sum)from(select seller_id, sum(price) as sum 
from Sales
group by seller_id)b );


--Q66.
--Table: Product

--Table: Sales

--Write an SQL query that reports the buyers who have bought S8 but not iPhone. Note that S8 and iPhone are products present in the Product table.
--Return the result table in any order.
select distinct buyer_id from Sales s
join Product p
on p.product_id = s.product_id
where p.product_name = 'S8'
and buyer_id not in
(
select buyer_id from Sales s
    join Product p on p.product_id = s.product_id
    where p.product_name = 'iPhone'
);


--Q67.
--Table: Customer
create table if not exists Customer
(
    customer_id int,
    name VARCHAR(50),
    visited_on date,
    amount int,
    constraint pk PRIMARY KEY (customer_id, visited_on)
);

INSERT into Customer VALUES (1,'Jhon','2019-01-01',100),(2,'Daniel','2019-01-02',110),(3,'Jade','2019-01-03',120),(4,'Khaled','2019-01-04',130),(5,'Winston','2019-01-05',110),(6,'Elvis','2019-01-06',140),(7,'Anna','2019-01-07',150),(8,'Maria','2019-01-08',80),(9,'Jaze','2019-01-09',110),(1,'Jhon','2019-01-10',130),(3,'Jade','2019-01-10',150);

select * from Customer;

--Write an SQL query to compute the moving average of how much the customer paid in a seven days
--window (i.e., current day + 6 days before). average_amount should be rounded to two decimal places.
--Return result table ordered by visited_on in ascending order.

select c1.visited_on, sum(c2.amount) as amount, 
    round(avg(c2.amount), 2) as average_amount
from (select visited_on, sum(amount) as amount 
      from Customer group by visited_on) c1
join (select visited_on, sum(amount) as amount 
      from Customer group by visited_on) c2
on datediff(c1.visited_on, c2.visited_on) between 0 and 6
group by c1.visited_on
having count(c2.amount) = 7;


--Q68.
--Table: Scores
create table if not exists Scores
(
    player_name VARCHAR(50),
    gender varchar(50),
    day date,
    score_points int,
    constraint pk PRIMARY KEY (gender, day)
);

insert into Scores VALUES ('Aron','F','2020-01-01',17),('Alice','F','2020-01-07',23),('Bajrang','M','2020-01-07',7),('Khali','M','2019-12-25',11),('Slaman','M','2019-12-30',13),('Joe','M','2019-12-31',3),('Jose','M','2019-12-18',2),('Priya','F','2019-12-31',23),('Priyanka','F','2019-12-30',17);

select * from Scores;


--Write an SQL query to find the total score for each gender on each day.
--Return the result table ordered by gender and day in ascending order.
select s1.gender, s1.day, sum(s2.score_points) as total from Scores s1, Scores s2
where s1.gender = s2.gender and s1.day >= s2.day
group by s1.gender, s1.day
order by s1.gender, s1.day;


--Q69.
--Table: Logs
create table if not exists Logs
(
    log_id int,
    constraint pk PRIMARY KEY (log_id)
);

insert into Logs VALUES (1),(2),(3),(7),(8),(10);

select * from Logs;

--Write an SQL query to find the start and end number of continuous ranges in the table Logs.
--Return the result table ordered by start_id
select min(log_id) as start_id, max(log_id) as end_id
from (select l.log_id, (l.log_id - l.row_num) as diff
      from (select log_id, row_number() over() as row_num from Logs) l
      ) l2
group by diff;


--Q70.
--Table: Students
create table if not exists Students
(
    student_id int,
    student_name VARCHAR(50),
    constraint pk PRIMARY KEY (student_id)
);

insert into Students VALUES (1,'Alice'),(2,'Bob'),(13,'John'),(6,'Alex');

select * from Students;

--Table: Subjects
create table if not exists Subjects
(
    subject_name VARCHAR(50),
    constraint pk PRIMARY KEY (subject_name)
);

insert into Subjects VALUES ('Math'),('Physics'),('Programming');

select * from Subjects;

--Table: Examinations
create table if not exists Examinations
(
    student_id int,
    subject_name VARCHAR(50)
);

INSERT into Examinations VALUES (1,'Math'),(1,'Physics'),(1,'Programming'),(2,'Programming'),(1,'Physics'),(1,'Math'),(13,'Math'),(13,'Programming'),(13,'Physics'),(2,'Math'),(1,'Math');

select * from Examinations;

--Write an SQL query to find the number of times each student attended each exam.
--Return the result table ordered by student_id and subject_name.
select a.student_id, a.student_name, b.subject_name, count(c.subject_name) as attended_exams
from Students as a
join Subjects as b
left join Examinations as c
on a.student_id = c.student_id and b.subject_name = c.subject_name
group by a.student_id, b.subject_name;


--Q71.
--Table: Employees
create table if not exists Employees
(
    employee_id int,
    employee_name VARCHAR(50),
    manager_id int,
    constraint pk PRIMARY KEY (employee_id)
);

insert into Employees VALUES (1,'Boss',1),(3,'Alice',3),(2,'Bob',1),(4,'Daniel',2),(7,'Luis',4),(8,'Jhon',3),(9,'Angela',8),(77,'Robert',1);

select * from Employees;

--Write an SQL query to find employee_id of all employees that directly or indirectly report their work to the head of the company.
--The indirect relation between managers will not exceed three managers as the company is small.
--Return the result table in any order.
select e3.employee_id from Employees e1, Employees e2, Employees e3
where e1.manager_id = 1 and e2.manager_id = e1.employee_id and e3.manager_id = e2.employee_id and e3.employee_id != 1;


--Q72.
--Table: Transactions
create table if not exists Transactions
(
    id int,
    country VARCHAR(50),
    state enum('approved', 'declined'),
    amount int,
    trans_date date,
    constraint pk PRIMARY KEY (id)
);

insert into Transactions VALUES (121,'US','approved',1000,'2018-12-18'),(122,'US','declined',2000,'2018-12-19'),(123,'US','approved',2000,'2019-01-01'),(124,'DE','approved',2000,'2019-01-07');


select * from Transactions;

--Write an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved transactions and their total amount.
--Return the result table in any order.
SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month, country
       , COUNT(1) AS trans_count
       , COUNT(if(state = 'approved', 1, NULL)) AS approved_count
       , SUM(amount) AS trans_total_amount
       , SUM(if(state = 'approved', amount, 0)) AS approved_total_amount
FROM Transactions
GROUP BY month, country;



--Q73.
--Table: Actions
create table if not exists Actions
(
    user_id int,
    post_id int,
    action_date date,
    action enum('view', 'like', 'reaction', 'comment', 'report', 'share'),
    extra VARCHAR(50)
);

insert into Actions VALUES (1,1,'2019-07-01','view',null),(1,1,'2019-07-01','like',null),(1,1,'2019-07-01','share',null),(2,2,'2019-07-04','view',null),(2,2,'2019-07-04','report','spam'),(3,4,'2019-07-04','view',null),(3,4,'2019-07-04','report','spam'),(4,3,'2019-07-02','view',null),(4,3,'2019-07-02','report','spam');

select * from Actions;

--Table: Removals
create table if not exists Removals
(
    post_id int,
    remove_date date,
    constraint pk PRIMARY KEY (post_id)
);

insert into Removals VALUES (2,'2019-07-20'),(3,'2019-07-18');

select * from Removals;

--Write an SQL query to find the average daily percentage of posts that got removed after being reported as spam, rounded to 2 decimal places.
SELECT ROUND(AVG(percentage),2) AS average_daily_percent
FROM (
SELECT action_date, 
(COUNT(DISTINCT b.post_id)/COUNT(DISTINCT a.post_id))*100 AS percentage 
FROM Actions AS a
LEFT JOIN Removals AS b
ON a.post_id = b.post_id
WHERE a.action = 'report'
AND a.extra = 'spam'
GROUP BY a.action_date
) AS tmp;


--Q74.
--Table: Activity
create table if not exists Activity
(
    player_id int,
    device_id int,
    event_date date,
    games_played int,
    constraint pk PRIMARY KEY (player_id, event_date)
);

insert into Activity VALUES (1,2,'2016-03-01',5),(1,2,'2016-03-02',6),(2,3,'2017-06-25',1),(3,1,'2016-03-02',0),(3,4,'2018-07-03',5);

select * from Activity;

--Write an SQL query to report the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of players.
WITH CTE AS (
SELECT
player_id, min(event_date) as event_start_date
from
Activity
group by player_id )

SELECT
round((count(distinct c.player_id) / (select count(distinct player_id) from Activity)),2)as fraction
FROM
CTE c
JOIN Activity a
on c.player_id = a.player_id
and datediff(c.event_start_date, a.event_date) = -1;


--Q75.
--Table: Activity
create table if not exists Activity
(
    player_id int,
    device_id int,
    event_date date,
    games_played int,
    constraint pk PRIMARY KEY (player_id, event_date)
);


insert into Activity VALUES (1,2,'2016-03-01',5),(1,2,'2016-03-02',6),(2,3,'2017-06-25',1),(3,1,'2016-03-02',0),(3,4,'2018-07-03',5);

select * from Activity;

-- Write an SQL query to report the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of players.
WITH CTE AS (
SELECT
player_id, min(event_date) as event_start_date
from
Activity
group by player_id )

SELECT
round((count(distinct c.player_id) / (select count(distinct player_id) from Activity)),2)as fraction
FROM
CTE c
JOIN Activity a
on c.player_id = a.player_id
and datediff(c.event_start_date, a.event_date) = -1;


--Q76.
--Table Salaries:
create table if not exists Salaries
(
    company_id int,
    employee_id int,
    employee_name VARCHAR(50),
    salary int,
    constraint pk PRIMARY KEY (company_id, employee_id)
);

insert into Salaries VALUES (1,1,'Tony',2000),(1,2,'Pronub',21300),(1,3,'Tyrrox',10800),(2,1,'Pam',300),(2,7,'Bassem',450),(2,9,'Hermione',700),(3,7,'Bocaben',100),(3,2,'Ognjen',2200),(3,13,'Nyan Cat',3300),(3,15,'Morning Cat',7777);

--Write an SQL query to find the salaries of the employees after applying taxes. Round the salary to the nearest integer.
--The tax rate is calculated for each company based on the following criteria:
--● 0% If the max salary of any employee in the company is less than $1000.
--● 24% If the max salary of any employee in the company is in the range [1000, 10000] inclusive.
--● 49% If the max salary of any employee in the company is greater than $10000.
--Return the result table in any order.
SELECT 
    t1.company_id,
    t1.employee_id,
    t1.employee_name,
    ROUND(CASE WHEN t2.max_sal >= 1000 AND t2.max_sal <= 10000 then salary * 0.76
        WHEN t2.max_sal > 10000 THEN salary * 0.51 
        Else salary end, 0) as salary
FROM Salaries as t1 JOIN (SELECT company_id, MAX(salary) as max_sal FROM Salaries GROUP BY 1) as t2
ON t1.company_id = t2.company_id;


--Q77.
--Table: Sales
create table if not exists Sales
(
    sale_date date,
    fruit enum ('apples','oranges'),
    sold_num int,
    constraint pk PRIMARY KEY (sale_date, fruit)
);

insert into Sales VALUES ('2020-05-01','apples',10), ('2020-05-01','oranges',8), ('2020-05-02','apples',15), ('2020-05-02','oranges',15), ('2020-05-03','apples',20), ('2020-05-03','oranges',0), ('2020-05-04','apples',15),('2020-05-04','oranges',16);

select * from Sales;

--Write an SQL query to report the difference between the number of apples and oranges sold each day.
--Return the result table ordered by sale_date.
select a.sale_date, a.sold_num - b.sold_num
from Sales a left join Sales b
on a.sale_date = b.sale_date
where a.fruit = 'apples' and b.fruit = 'oranges';


--Q78.
--Table Variables:
create table if not exists Variables
(
    name varchar(50),
    value int,
    constraint pk PRIMARY KEY (name)
);

insert into Variables VALUES ('x',66),('y',77);

select * from Variables;

--Table Expressions:
create table if not exists Expressions
(
    left_operand varchar(50),
    operator enum ('<', '>', '='),
    right_operand VARCHAR(50),
    constraint pk PRIMARY KEY (left_operand, operator, right_operand)
);


insert into Expressions VALUES ('x','>','y'),('x','<','y') ,('x','=','y'),('y','>','x'),('y','<','x'),('x','=','x');   

select * from Expressions;

--Write an SQL query to evaluate the boolean expressions in Expressions table.
--Return the result table in any order.

select e.left_operand, e.operator, e.right_operand,
    case
        when e.operator = '<' then if(l.value < r.value,'true','false')
        when e.operator = '>' then if(l.value > r.value,'true','false')
        else if(l.value = r.value,'true','false')
    end as value
from Expressions e 
left join Variables l on e.left_operand = l.name 
left join Variables r on e.right_operand = r.name;


--Q79.
--Table: Movies
create table if not exists Movies
(
    movie_id int,
    title VARCHAR(50),
    constraint pk PRIMARY KEY (movie_id)
);

insert into Movies VALUES (1,'Avengers'),(2,'Frozen 2'),(3,'Joker');

select * from Movies;

--Table: Users
create table if not exists Users
(
    user_id int,
    name VARCHAR(50),
    constraint pk PRIMARY KEY (user_id)
);


insert into Users VALUES (1,'Daniel'),(2,'Monica'),(3,'Maria'),(4,'James');

select * from Users;

--Table: MovieRating
create table if not exists MovieRating
(
    movie_id int,
    user_id int,
    rating int,
    created_at date,
    constraint pk PRIMARY KEY (movie_id, user_id)
);

insert into MovieRating VALUES (1,1,3,'2020-01-12'),(1,2,4,'2020-02-11'),(1,3,2,'2020-02-12'),(1,4,1,'2020-01-01'),(2,1,5,'2020-02-17'),(2,2,2,'2020-02-01'),(2,3,2,'2020-03-01'),(3,1,3,'2020-02-22'),(3,2,4,'2020-02-25');

select * from MovieRating;

--Write an SQL query to:
--● Find the name of the user who has rated the greatest number of movies. In case of a tie, return the lexicographically smaller user name.
--● Find the movie name with the highest average rating in February 2020. In case of a tie, return
--the lexicographically smaller movie name.

SELECT user_name AS results FROM
(
SELECT a.name AS user_name, COUNT(*) AS counts FROM MovieRating AS b
    JOIN Users AS a
    on a.user_id = b.user_id
    GROUP BY b.user_id
    ORDER BY counts DESC, user_name ASC LIMIT 1
) first_query
UNION
SELECT movie_name AS results FROM
(
SELECT c.title AS movie_name, AVG(d.rating) AS rate FROM MovieRating AS d
    JOIN Movies AS c
    on c.movie_id = d.movie_id
    WHERE substr(d.created_at, 1, 7) = '2020-02'
    GROUP BY d.movie_id
    ORDER BY rate DESC, movie_name ASC LIMIT 1
) second_query;


--Q80.
--Table Person:
create table if not exists Person
(
    id int,
    name VARCHAR(50),
    phone_number VARCHAR(50),
    constraint pk PRIMARY KEY (id)
);

insert into Person VALUES (3,'Jonathan','051-1234567'),(12,'Elvis','051-7654321'),(1,'Moncef','212-1234567'),(2,'Maroua','212-6523651'),(7,'Meir','972-1234567'),(9,'Rachel','972-0011100');


select * from Person;

--Table Country:
create table if not exists Country
(
    name VARCHAR(50),
    country_code VARCHAR(50),
    constraint pk PRIMARY KEY (country_code)
);

insert into Country values ('Peru',51),('Israel',972),('Morocco',212),('Germany',49),('Ethiopia',251);

select * from Country;

--Table Calls:
create table if not exists Calls
(
    caller_id int,
    callee_id int,
    duration int
);

insert into Calls VALUES (1,9,33),(2,9,4),(1,2,59),(3,12,102),(3,12,330),(12,3,5),(7,9,13),(7,1,3),(9,7,1),(1,7,7);

select * from Calls;



--Write an SQL query to find the countries where this company can invest.
--Return the result table in any order.
SELECT
 co.name AS country
FROM
 Person p
 JOIN
     Country co
     ON SUBSTRING(phone_number,1,3) = country_code
 JOIN
     Calls c
     ON p.id IN (c.caller_id, c.callee_id)
GROUP BY
 co.name
HAVING
 AVG(duration) > (SELECT AVG(duration) FROM Calls);


--Q81.
 --STUDENTS table
 create table if not exists STUDENTS
(
    id int,
    name VARCHAR(50),
    marks int
);

insert into STUDENTS VALUES (1,'Ashley',81),(2,'Samantha',75),(4,'Julia',76),(3,'Belvet',84);

select * from STUDENTS;

--Query the Name of any student in STUDENTS who scored higher than 75 Marks. Order your output by the last three characters of each name. If two or more students both have names ending in the same last three characters (i.e.: Bobby, Robby, etc.), secondary sort them by ascending ID.
SELECT NAME FROM STUDENTS WHERE MARKS > 75 ORDER BY RIGHT(NAME,3), ID ASC;


--Q82.
--Employee table
 create table if not exists Employee
(
    employee_id int,
    name VARCHAR(50),
    months int,
    salary int
);


insert into Employee VALUES (12228,'Rose',15,1968),(33645,'Angela',1,3443),(45692,'Frank',17,1608),(56118,'Patrick',7,1345),(59725,'Lisa',11,2330),(74197,'Kimberly',16,4372),(78454,'Bonnie',8,1771),(83565,'Michael',6,2017),(98607,'Todd',5,3396),(99989,'Joe',9,3573);

select * from Employee;

--Write a query that prints a list of employee names (i.e.: the name attribute) from the Employee table in alphabetical order.
SELECT name FROM Employee ORDER BY name;


--Q83.
--Employee table
--Write a query that prints a list of employee names (i.e.: the name attribute) for employees in Employee having a salary greater than $2000 per month who have been employees for less than 10 months. Sort your result by ascending employee_id.
SELECT name FROM Employee WHERE salary > 2000 AND months < 10 ORDER BY employee_id;


--Q84.
--TRIANGLES table
 create table if not exists TRIANGLES
(
    A int,
    B int,
    C int
);


insert into TRIANGLES VALUES (20,20,23),(20,20,20),(20,21,22),(13,14,30);

select * from TRIANGLES;


--Write a query identifying the type of each record in the TRIANGLES table using its three side lengths.
--Output one of the following statements for each record in the table:
--● Equilateral: It's a triangle with sides of equal length.
--● Isosceles: It's a triangle with sides of equal length.
--● Scalene: It's a triangle with sides of differing lengths.
--● Not A Triangle: The given values of A, B, and C don't form a triangle.
SELECT CASE
WHEN A + B <= C OR A + C <= B OR B + C <= A THEN 'Not A Triangle'
WHEN A = B AND B = C THEN 'Equilateral'
WHEN A = B OR B = C OR A = C THEN 'Isosceles'
ELSE 'Scalene'
END
FROM TRIANGLES;


--Q85.
--user_transactions Table:
create table if not exists user_transactions
(
    transaction_id int,
    product_id int,
    spend decimal (5,2),
    transaction_date DATETIME
);

insert into user_transactions VALUES (1341,123424,1500.60,'12/31/2019 12:00:00'),(1423,123424,1000.20,'12/31/2020 12:00:00')(1623,123424,1246.44,'12/31/2021 12:00:00')(1322,123424,2145.32,'12/31/2022 12:00:00');

select * from user_transactions;

--Assume you are given the table below containing information on user transactions for particular products. Write a query to obtain the year-on-year growth rate for the total spend of each product for each year.



--Q86.
--inventory table:
create table if not exists inventory
(
    item_id int,
    item_type VARCHAR(50),
    item_category VARCHAR(50),
    square_footage DECIMAL
);

insert into inventory VALUES (1374,'prime_eligible','mini refrigerator',68.00),(4245,'not_prime','standing lamp',26.40),(2452,'prime_eligible','television',85.00),(3255,'not_prime','side table',22.60),(1672,'prime_eligible','laptop',8.50);

select * from inventory;

--Write a SQL query to find the number of prime and non-prime items that can be stored in the 500,000 square feet warehouse. Output the item type and number of items to be stocked.
SELECT
  item_type,
  SUM(square_footage) AS total_sqft,
  COUNT(*) AS item_count
FROM inventory
GROUP BY item_type;


--Q87.
--user_actions Table:
create table if not exists user_actions
(
    user_id int,
    event_id int,
    event_type enum ("sign-in", "like", "comment"),
    event_date DATETIME
);

insert into user_actions VALUES (445,7765,'sign-in','05/31/2022 12:00:00'),(742,6458,'sign-in','06/03/2022 12:00:00'),(445,3634,'like','06/05/2022 12:00:00'),(742,1374,'comment','06/05/2022 12:00:00'),(648,3124,'like','06/18/2022 12:00:00');

select * from user_actions;

--Write a query to obtain the active user retention in July 2022. Output the month (in numerical format 1, 2, 3) and the number of monthly active users (MAUs).

SELECT 
  EXTRACT(MONTH FROM curr_month.event_date) AS mth, 
  COUNT(DISTINCT curr_month.user_id) AS monthly_active_users 
FROM user_actions AS curr_month
WHERE EXISTS (
  SELECT last_month.user_id 
  FROM user_actions AS last_month
  WHERE last_month.user_id = curr_month.user_id
    AND EXTRACT(MONTH FROM last_month.event_date) =
    EXTRACT(MONTH FROM curr_month.event_date - interval '1 month')
)
  AND EXTRACT(MONTH FROM curr_month.event_date) = 7
  AND EXTRACT(YEAR FROM curr_month.event_date) = 2022
GROUP BY EXTRACT(MONTH FROM curr_month.event_date);


--Q88.
--search_frequency Table:
create table if not exists search_frequency
(
    searches int,
    num_users int
);


insert into search_frequency VALUES (1,2),(2,2),(3,3),(4,1);

select * from search_frequency;


--Write a query to report the median of searches made by a user. Round the median to one decimal point
WITH RECURSIVE cte AS (
  SELECT searches, num_users as NU FROM search_frequency

UNION ALL
  
SELECT cte.searches,
cte.NU - 1
FROM cte WHERE NU > 0
)

select PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY searches) AS median FROM cte
WHERE nu > 0;


--Q89.
--advertiser Table:
create table if not exists advertiser
(
    user_id VARCHAR(50),
    status VARCHAR(50)
);


insert into advertiser VALUES ('bing','NEW'),('yahoo','NEW'),('alibaba','EXISTING');

select * from advertiser;

--daily_pay Table:
create table if not exists daily_pay
(
    user_id VARCHAR(50),
    paid decimal
);

insert into daily_pay VALUES ('yahoo',45.00),('alibaba',100.00),('target',13.00);

select * from daily_pay;

--Write a query to update the Facebook advertiser's status using the daily_pay table. Advertiser is  two-column table containing the user id and their payment status based on the last payment an daily_pay table has current information about their payment. Only advertisers who paid will show up in this table.Output the user id and current payment status sorted by the user id.

WITH payment_status AS (
SELECT
  advertiser.user_id,
  advertiser.status,
  payment.paid
FROM advertiser
LEFT JOIN daily_pay AS payment
  ON advertiser.user_id = payment.user_id

UNION

SELECT
  payment.user_id,
  advertiser.status,
  payment.paid
FROM daily_pay AS payment
LEFT JOIN advertiser
  ON advertiser.user_id = payment.user_id
)

SELECT
  user_id,
  CASE WHEN paid IS NULL THEN 'CHURN'
  	WHEN status != 'CHURN' AND paid IS NOT NULL THEN 'EXISTING'
  	WHEN status = 'CHURN' AND paid IS NOT NULL THEN 'RESURRECT'
  	WHEN status IS NULL THEN 'NEW'
  END AS new_status
FROM payment_status
ORDER BY user_id;

--Q90.
--server_utilization Table:
create table if not exists server_utilization
(
    server_id int,
    status_time TIMESTAMP,
    session_status VARCHAR(50)
);

insert into server_utilization VALUES(1,'08/02/2022 10:00:00','start'),(1,'08/04/2022 10:00:00','stop  '),(2,'08/17/2022 10:00:00','start'),(2,'08/24/2022 10:00:00','stop');


select * from server_utilization;

--Write a query that calculates the total time that the fleet of servers was running. The output should be in units of full days.



--Q91.
--transactions Table:
create table if not exists transactions
(
    transaction_id int,
    merchant_id int,
    credit_card_id INT,
    amount int,
    transaction_timestamp datetime
);


insert into transactions values (1,101,1,100,'09/25/2022 12:00:00'),(2,101,1,100,'09/25/2022'),(3,101,1,100,'09/25/2022 12:28:00'),(4,102,2,300,'09/25/2022 12:00:00'),(6,102,2,400,'09/25/2022 14:00:00');

select * from transactions;

--Sometimes, payment transactions are repeated by accident; it could be due to user error, API failure or a retry error that causes a credit card to be charged twice. Using the transactions table, identify any payments made at the same merchant with the same credit card for the same amount within 10 minutes of each other. Count such repeated payments.
WITH payments AS (
  SELECT 
    merchant_id, 
    EXTRACT(EPOCH FROM transaction_timestamp - 
      LAG(transaction_timestamp) OVER(
        PARTITION BY merchant_id, credit_card_id, amount 
        ORDER BY transaction_timestamp)
    )/60 AS minute_difference 
  FROM transactions) 

SELECT COUNT(merchant_id) AS payment_count
FROM payments 
WHERE minute_difference <= 10;


--Q92.
--orders Table:
create table if not exists orders
(
    order_id int,
    customer_id int,
    trip_id INT,
    status enum ('completed,successfully','completed incorrectly', 'never received'),
    order_timestamp timestamp
);

insert into orders VALUES (727424,8472,100463,'completed successfully','06/05/2022 09:12:00'),(242513,2341,100482,'completed incorrectly','06/05/2022 14:40:00'),(141367,1314,100362,'completed incorrectly','06/07/2022 15:03:00'),(582193,5421,100657,'never_received','07/07/2022 15:22:00'),(253613,1314,100213,'completed successfully','06/12/2022 13:43:00');


select * from orders;

--trips Table:
create table if not exists trips
(
    dasher_id int,
    trip_id int,
    estimated_delivery_timestamp timestamp,
    actual_delivery_timestamp timestamp
);

insert into trips VALUES (101,100463,'06/05/2022 09:42:00','06/05/2022 09:38:00'),(102,100482,'06/05/2022 15:10:00','06/05/2022 15:46:00'),(101,100362,'06/07/2022 15:33:00','06/07/2022 16:45:00'),(102,100657,'07/07/2022 15:52:00','-'),(103,100213,'06/12/2022 14:13:00','06/12/2022 14:10:00');

select * from trips;

--customers Table:
create table if not exists customers
(
    customer_id int,
    signup_timestamp timestamp
);

insert into customers VALUES (8472,'05/30/2022 00:00:00'),(2341,'06/01/2022 00:00:00'),(1314,'06/03/2022 00:00:00'),(1435,'06/05/2022 00:00:00'),(5421,'06/07/2022 00:00:00');

select * from customers;

--Write a query to find the bad experience rate in the first 14 days for new users who signed up in June 2022. Output the percentage of bad experience rounded to 2 decimal places.



--Q93
--Table: Scores
create table if not exists Scores
(
    player_name VARCHAR(50),
    gender VARCHAR(50),
    day DATE,
    score_points int,
    constraint pk PRIMARY KEY (gender, day)
);

insert into Scores VALUES ('Aron','F','2020-01-01',17),('Alice','F','2020-01-07',23),('Bajrang','M','2020-01-07',7),('Khali','M','2019-12-25',11),('Slaman','M','2019-12-30',13),('Joe','M','2019-12-31',3),('Jose','M','2019-12-18',2),('Priya','F','2019-12-31',23),('Priyanka','F','2019-12-30',17);


--Write an SQL query to find the total score for each gender on each day. Return the result table ordered by gender and day in ascending order. The query result format is in the following example.
select s1.gender, s1.day, sum(s2.score_points) as total from Scores s1, Scores s2
where s1.gender = s2.gender and s1.day >= s2.day
group by s1.gender, s1.day
order by s1.gender, s1.day;



--Q94.
--Table Person:
create table if not exists Person
(
    id int,
    name VARCHAR(50),
    phone_number VARCHAR(50),
    constraint pk PRIMARY KEY (id)
);

insert into Person VALUES (3,'Jonathan','051-1234567'),(12,'Elvis','051-7654321'),(1,'Moncef','212-1234567'),(2,'Maroua','212-6523651'),(7,'Meir','972-1234567'),(9,'Rachel','972-0011100');

select * from Person;

--Country table:
create table if not exists Country
(
    name VARCHAR(50),
    country_code VARCHAR(50),
    constraint pk PRIMARY KEY (country_code)
);

insert into Country VALUES ('Peru',51),('Israel',972),('Morocco',212),('Germany',49),('Ethiopia',251);

select * from Country;

--Table Calls:
create table if not exists Calls
(
    caller_id int,
    callee_id int,
    duration int
);

insert into Calls VALUES (1,9,33),(2,9,4),(1,2,59),(3,12,102),(3,12,330),(12,3,5),(7,9,13),(7,1,3),(9,7,1),(1,7,7);

select * from Calls;

--Write an SQL query to find the countries where this company can invest.
--Return the result table in any order.
SELECT
 co.name AS country
FROM
 Person p
 JOIN
     Country co
     ON SUBSTRING(phone_number,1,3) = country_code
 JOIN
     Calls c
     ON p.id IN (c.caller_id, c.callee_id)
GROUP BY
 co.name
HAVING
 AVG(duration) > (SELECT AVG(duration) FROM Calls);


 --Q95.
--Table: Numbers
create table if not exists Numbers
(
    num int,
    frequency int,
    constraint pk PRIMARY KEY (num)
);

insert into Numbers VALUES (0,7),(1,1),(2,3),(3,1);

select * from Numbers;

--Write an SQL query to report the median of all the numbers in the database after decompressing the Numbers table. Round the median to one decimal point.
SET @rowindex := -1;
 
SELECT
   AVG(d.frequency) as Median 
FROM
   (SELECT @rowindex:=@rowindex + 1 AS rowindex,
           Numbers.frequency AS frequency
    FROM Numbers
    ORDER BY Numbers.frequency) AS d
WHERE
d.rowindex IN (FLOOR(@rowindex / 2), CEIL(@rowindex / 2));


--Q96.
--Table: Salary
create table if not exists Salary
(
    id int,
    employee_id int,
    amount int,
    pay_date date,
    constraint pk PRIMARY KEY (id)
);

insert into Salary VALUES (1,1,9000,'2017/03/31'),(2,2,6000,'2017/03/31'),(3,3,10000,'2017/03/31'),(4,1,7000,'2017/02/28'),(5,2,6000,'2017/02/28'),(6,3,8000,'2017/02/28');

select * from Salary;

--Employee table:
create table if not exists Employee
(
    employee_id int,
    department_id int,
    constraint pk PRIMARY KEY (employee_id)
);

insert into Employee VALUES (1,1),(2,2),(3,2);

--Write an SQL query to report the comparison result (higher/lower/same) of the average salary of employees in a department to the company's average salary. Return the result table in any order.
select 
    pay_month,
    department_id, 
    case when dept_avg > comp_avg then 'higher' when dept_avg < comp_avg then 'lower' else 'same' end comparison
from (
        select  date_format(b.pay_date, '%Y-%m') pay_month, a.department_id, avg(b.amount) dept_avg,  d.comp_avg
        from Employee a 
        inner join Salary b
            on (a.employee_id = b.employee_id) 
        inner join (select date_format(c.pay_date, '%Y-%m') pay_month, avg(c.amount) comp_avg 
                    from Salary c 
                    group by date_format(c.pay_date, '%Y-%m')) d 
            on ( date_format(b.pay_date, '%Y-%m') = d.pay_month)
group by date_format(b.pay_date, '%Y-%m'), department_id, d.comp_avg) final;


--Q97.
--Table: Activity
create table if not exists Activity
(
    player_id int,
    device_id int,
    event_date date,
    games_played int,
    constraint pk PRIMARY KEY (player_id, event_date)
);


insert INTO Activity VALUES (1,2,'2016-03-01',5),(1,2,'2016-03-02',6),(2,3,'2017-06-25',1),(3,1,'2016-03-01',0),(3,4,'2016-07-03',5);


select * from Activity;

--Write an SQL query to report for each install date, the number of players that installed the game on that day, and the day one retention.Return the result table in any order.

select a1.event_date as install_dt, count(a1.player_id) as installs, round(count(a3.player_id) / count(a1.player_id), 2) as Day1_retention
    from Activity a1 left join Activity a2
    on a1.player_id = a2.player_id and a1.event_date > a2.event_date
    left join Activity a3
    on a1.player_id = a3.player_id and datediff(a3.event_date, a1.event_date) = 1
    where a2.event_date is null
    group by a1.event_date;


--Q98.
--Table: Players
create table if not exists Players
(
    player_id int,
    group_id int,
    constraint pk PRIMARY KEY (player_id)
);

insert into Players VALUES (15,1), (25,1), (30,1), (45,1), (10,2), (35,2), (50,2), (20,3), (40,3);

select * from Players;

--Table: Matches
create table if not exists Matches
(
    match_id int,
    first_player int,
    second_player int,
    first_score int,
    second_score int,
    constraint pk PRIMARY KEY (match_id)
);

insert into Matches VALUES (1,15,45,3,0),(2,30,25,1,2),(3,30,15,2,0),(4,40,20,5,2),(5,35,50,1,1);

select * from Matches;

--Write an SQL query to find the winner in each group.
--Return the result table in any order.

select group_id,player_id from 
(select group_id,player_id,sum((
    case when player_id = first_player then first_score
         when player_id = second_player then second_score
         end
)) as totalScores
from Players p,Matches m
where p.player_id = m.first_player
or p.player_id = m.second_player
group by group_id,player_id
order by group_id,totalScores desc,player_id) as temp
group by group_id
order by group_id,totalScores desc,player_id;



--Q99.
--Table: Student
create table if not exists Student
(
    student_id int,
    student_name VARCHAR(50),
    constraint pk PRIMARY KEY (student_id)
);


insert into Student VALUES (1,'Daniel'),(2,'Jade'),(3,'Stella'),(4,'Jonathan'),(5,'Will');

select * from Student;

--Table: Exam
create table if not exists Exam
(
    exam_id int,
    student_id int,
    score int,
    constraint pk PRIMARY KEY (exam_id, student_id)
);

insert into Exam VALUES (10,1,70),(10,2,80),(10,3,90),(20,1,80),(30,1,70),(30,3,80),(30,4,90),(40,1,60),(40,2,70),(40,4,80);

select * from Exam;


--Write an SQL query to report the students (student_id, student_name) being quiet in all exams. Do not return the student who has never taken any exam.Return the result table ordered by student_id.
select 
   Student.*
from Exam 
inner join Student on Student.student_id=Exam.student_id
group by student_id 
having max(score) not in (select max(score) from Exam) 
   and min(score) not in (select min(score) from Exam);


--Q100.
--Table: Student
--Exam table:
--Write an SQL query to report the students (student_id, student_name) being quiet in all exams. Do not return the student who has never taken any exam.Return the result table ordered by student_id.
select 
   Student.*
from Exam 
inner join Student on Student.student_id=Exam.student_id
group by student_id 
having max(score) not in (select max(score) from Exam) 
   and min(score) not in (select min(score) from Exam);



--Q 101.
--Table: UserActivity
create table if not exists UserActivity
(
    username VARCHAR(50),
    activity varchar(50),
    startDate date,
    endDate date
);

insert INTO UserActivity VALUES ('Alice','Travel','2020-02-12','2020-02-20'),('Alice','Dancing','2020-02-21','2020-02-23'),('Alice','Travel','2020-02-24','2020-02-28'),('Bob','Travel','2020-02-11','2020-02-18');

select * from UserActivity;

--Write an SQL query to show the second most recent activity of each user.If the user only has one activity, return that one. A user cannot perform more than one activity at the same time.Return the result table in any order.
select distinct username, activity, startDate, endDate
from
    (select u.*,
           rank() over (partition by username order by startDate desc) as rnk,
           count(activity) over (partition by username) as num
    from UserActivity u) t
where (num <> 1 and rnk = 2) or (num = 1 and rnk = 1);

--Q102.
--Table: UserActivity

--Write an SQL query to show the second most recent activity of each user.If the user only has one activity, return that one. A user cannot perform more than one activity at the same time. Return the result table in any order.
select distinct username, activity, startDate, endDate
from
    (select u.*,
           rank() over (partition by username order by startDate desc) as rnk,
           count(activity) over (partition by username) as num
    from UserActivity u) t
where (num <> 1 and rnk = 2) or (num = 1 and rnk = 1);



--Q103.
--STUDENTS table

 create table if not exists STUDENTS
(
    id int,
    name VARCHAR(50),
    marks int
);

insert into STUDENTS VALUES (1,'Ashley',81),(2,'Samantha',75),(4,'Julia',76),(3,'Belvet',84);

select * from STUDENTS;

--Query the Name of any student in STUDENTS who scored higher than 75 Marks. Order your output by the last three characters of each name. If two or more students both have names ending in the same last three characters (i.e.: Bobby, Robby, etc.), secondary sort them by ascending ID.
SELECT NAME FROM STUDENTS WHERE MARKS > 75 ORDER BY RIGHT(NAME,3), ID ASC;


--Q104.
--Employee table

 create table if not exists Employee
(
    employee_id int,
    name VARCHAR(50),
    months int,
    salary int
);


insert into Employee VALUES (12228,'Rose',15,1968),(33645,'Angela',1,3443),(45692,'Frank',17,1608),(56118,'Patrick',7,1345),(59725,'Lisa',11,2330),(74197,'Kimberly',16,4372),(78454,'Bonnie',8,1771),(83565,'Michael',6,2017),(98607,'Todd',5,3396),(99989,'Joe',9,3573);

select * from Employee;

--Write a query that prints a list of employee names (i.e.: the name attribute) from the Employee table in alphabetical order.
SELECT name FROM Employee ORDER BY name;


--Q105.
--Write a query that prints a list of employee names (i.e.: the name attribute) for employees in Employee having a salary greater than $2000 per month who have been employees for less than 10 months. Sort your result by ascending employee_id.
SELECT name FROM Employee WHERE salary > 2000 AND months < 10 ORDER BY employee_id;


--Q106
--TRIANGLES table
create table if not exists TRIANGLES
(
    A int,
    B int,
    C int
);


insert into TRIANGLES VALUES (20,20,23),(20,20,20),(20,21,22),(13,14,30);

select * from TRIANGLES;


--Write a query identifying the type of each record in the TRIANGLES table using its three side lengths.
--Output one of the following statements for each record in the table:
--● Equilateral: It's a triangle with sides of equal length.
--● Isosceles: It's a triangle with sides of equal length.
--● Scalene: It's a triangle with sides of differing lengths.
--● Not A Triangle: The given values of A, B, and C don't form a triangle.
SELECT CASE
WHEN A + B <= C OR A + C <= B OR B + C <= A THEN 'Not A Triangle'
WHEN A = B AND B = C THEN 'Equilateral'
WHEN A = B OR B = C OR A = C THEN 'Isosceles'
ELSE 'Scalene'
END
FROM TRIANGLES;



--Q107.
--EMPLOYEES table
create table if not exists EMPLOYEES
(
    id int,
    name VARCHAR(50),
    salary int
);


insert into EMPLOYEES VALUES (1,'Kristeen',1420), (2,'Ashley',2006), (3,'Julia',2210), (4,'Maria',3000);

select * from EMPLOYEES;

--Write a query calculating the amount of error (i.e.: actual - miscalculated average monthly salaries), and round it up to the next integer.
select ceil(avg(salary) - avg(replace(salary, '0', ''))) from EMPLOYEES;


--Q108.
--Employee table
 select MAX(salary*months), COUNT(*) from Employee where (salary * months) >= (select MAX(salary * months) from Employee);



--Q109.
--OCCUPATIONS table
create table if not exists OCCUPATIONS
(
    Name VARCHAR(50),
    Occupation VARCHAR(50)
);


insert into OCCUPATIONS VALUES ('Samantha','Doctor'),('Julia','Actor'),('Maria','Actor'),('Meera','Singer'),('Ashely','Professor'),('Ketty','Professor'),('Christeen','Professor'),('Jane','Actor'),('Jenny','Doctor'),('Priya','Singer');

select * from OCCUPATIONS;

--Query the number of occurrences of each occupation in OCCUPATIONS. Sort the occurrences in ascending order,
(
  SELECT CONCAT(NAME, '(', SUBSTRING(Occupation, 1, 1), ')') as THETEXT, '1' as SELECTNUMBER
    FROM OCCUPATIONS
)
UNION ALL 
(
  SELECT CONCAT('There are total ', COUNT(*),' ', Occupation, (IF (COUNT(*) > 1, 's',''))) as THETEXT, '2' as SELECTNUMBER
   FROM OCCUPATIONS GROUP BY Occupation
)
ORDER BY SELECTNUMBER ASC, THETEXT ASC;


--Q110.
--Pivot the Occupation column in OCCUPATIONS so that each Name is sorted alphabetically and displayed underneath its corresponding Occupation. The output column headers should be Doctor, Professor, Singer, and Actor, respectively.
select
    Doctor,
    Professor,
    Singer,
    Actor
from (
    select
        NameOrder,
        max(case Occupation when 'Doctor' then Name end) as Doctor,
        max(case Occupation when 'Professor' then Name end) as Professor,
        max(case Occupation when 'Singer' then Name end) as Singer,
        max(case Occupation when 'Actor' then Name end) as Actor
    from (
            select
                Occupation,
                Name,
                row_number() over(partition by Occupation order by Name ASC) as NameOrder
            from OCCUPATIONS
         ) as NameLists
    group by NameOrder
    ) as Names;


--Q111.
--Table, BST,
create table if not exists BST
(
    N int,
    P int
);

insert into BST VALUES(1,2),(3,2),(6,8),(9,8),(2,5),(8,5),(5,null);

select * from BST;


--Write a query to find the node type of Binary Tree ordered by the value of the node. Output one of the following for each node:
--● Root: If node is root node.
--● Leaf: If node is leaf node.
--● Inner: If node is neither root nor leaf node.

SELECT N,
CASE
WHEN P IS NULL THEN 'Root'
WHEN N IN (SELECT P FROM BST) THEN 'Inner'
ELSE 'Leaf'
END
FROM BST
ORDER by N;


--Q112 .


--Given the table schemas below, write a query to print the company_code, founder name, total number of lead managers, total number of senior managers, total number of managers, and total number of employees. Order your output by ascending company_code.

--Company
create table if not exists Company
(
    company_code  VARCHAR(50),
    founder VARCHAR(50)
);

insert into Company VALUES ('C1','Monika'),('C2','Samantha');

select * from Company;

--Lead_Manager
create table if not exists Lead_Manager
(
    lead_manager_code  VARCHAR(50),
    company_code VARCHAR(50)
);

insert into Lead_Manager VALUES ('LM1','C1'),('LM2','C2');

select * from Lead_Manager;


--Senior_Manager
create table if not exists Senior_Manager
(
    senior_manager_code  VARCHAR(50),
    lead_manager_code VARCHAR(50),
    company_code VARCHAR(50)
);

insert into Senior_Manager VALUES ('SM1','LM1','C1'),('SM2','LM1','C1'),('SM3','LM2','C2');

select * from Senior_Manager;

--Manager Table:
create table if not exists Manager
(
    manager_code  VARCHAR(50),
    senior_manager_code VARCHAR(50),
    lead_manager_code VARCHAR(50),
    company_code VARCHAR(50)
);

insert into Manager VALUES ('M1','SM1','LM1','C1'),('M2','SM3','LM2','C2'),('M3','SM3','LM2','C2');

select * from Manager;

--Employee:
create table if not exists Employee
(
    employee_code  VARCHAR(50),
    manager_code VARCHAR(50),
    senior_manager_code VARCHAR(50),
    lead_manager_code VARCHAR(50),
    company_code VARCHAR(50)
);

insert into Employee VALUES ('E1','M1','SM1','LM1','C1'),('E2','M1','SM1','LM1','C1'),('E3','M2','SM3','LM2','C2'),('E4','M3','SM3','LM2','C2');

select * from Employee;

SELECT c.company_code, c.founder, COUNT(DISTINCT e.lead_manager_code), COUNT(DISTINCT e.senior_manager_code), COUNT(DISTINCT e.manager_code), COUNT(DISTINCT e.employee_code) FROM Company c
JOIN Employee e ON c.company_code = e.company_code GROUP BY c.company_code, c.founder ORDER BY c.company_code;


--Q113.
--Write a query to print all prime numbers less than or equal to 1000. Print your result on a single line,and use the ampersand () character as your separator (instead of a space).
select listagg(Prime_Number,'&') within group(order by Prime_Number)
from (select L Prime_Number from
     (select Level L 
     from Dual
     connect by Level <= 1000),
     (select Level M
     from Dual
     connect by Level <= 1000)
     where M <= L
     group by L
     having count(case when L/M = trunc(L/M) then 'Y' end) = 2
     order by L);


--Q114.
--P(R) represents a pattern drawn by Julia in R rows. The following pattern represents P(5):
--*
--* *
--* * *
--* * * *
--* * * * *
--Write a query to print the pattern P(20).

SELECT SYS_CONNECT_BY_PATH(NULL, '* ') FROM DUAL CONNECT BY ROWNUM <= 20 ORDER BY 1 DESC;





--Q115.
--P(R) represents a pattern drawn by Julia in R rows. The following pattern represents P(5):
--* * * * *
--* * * *
--* * *
--* *
--*
--Write a query to print the pattern P(20).
SELECT SYS_CONNECT_BY_PATH(NULL, '* ') FROM DUAL CONNECT BY ROWNUM <= 20 ORDER BY 1 DESC;
SET @no_of_lines = 5 + 1;

SELECT REPEAT('* ', @no_of_lines := @no_of_lines -1) 
FROM INFORMATION_SCHEMA.TABLES
WHERE @no_of_lines > 0;


--Q116
--Functions,
create table if not exists Functions
(
    X int,
    Y int
);

insert into Functions VALUES (20,20),(20,20),(20,21),(23,22),(22,23),(21,20);

select * from Functions;

--Write a query to output all such symmetric pairs in ascending order by the value of X. List the row such that X1 ≤ Y1.


SELECT f1.X, f1.Y FROM Functions AS f1 
WHERE f1.X = f1.Y AND
(SELECT COUNT(*) FROM Functions WHERE X = f1.X AND Y = f1.Y) > 1
UNION
SELECT f1.X, f1.Y from Functions AS f1
WHERE EXISTS(SELECT X, Y FROM Functions WHERE f1.X = Y AND f1.Y = X AND f1.X < X)
ORDER BY X;



--Q117.
--STUDENTS TABLE
--Query the Name of any student in STUDENTS who scored higher than 75 Marks. Order your output by the last three characters of each name. If two or more students both have names ending in the same last three characters (i.e.: Bobby, Robby, etc.), secondary sort them by ascending ID.
create table if not exists STUDENTS
(
    id int,
    name VARCHAR(50),
    marks int
);

insert into STUDENTS VALUES (1,'Ashley',81),(2,'Samantha',75),(4,'Julia',76),(3,'Belvet',84);

select * from STUDENTS;

--Query the Name of any student in STUDENTS who scored higher than 75 Marks. Order your output by the last three characters of each name. If two or more students both have names ending in the same last three characters (i.e.: Bobby, Robby, etc.), secondary sort them by ascending ID.
SELECT NAME FROM STUDENTS WHERE MARKS > 75 ORDER BY RIGHT(NAME,3), ID ASC;


--Q118.
--Employee table
create table if not exists Employee
(
    employee_id int,
    name VARCHAR(50),
    months int,
    salary int
);

insert into Employee VALUES (12228,'Rose',15,1968),(33645,'Angela',1,3443),(45692,'Frank',17,1608),(56118,'Patrick',7,1345),(59725,'Lisa',11,2330),(74197,'Kimberly',16,4372),(78454,'Bonnie',8,1771),(83565,'Michael',6,2017),(98607,'Todd',5,3396),(99989,'Joe',9,3573);

select * from Employee;

--Write a query that prints a list of employee names (i.e.: the name attribute) from the Employee table in alphabetical order.
SELECT name FROM Employee ORDER BY name;


--Q119..
--Write a query that prints a list of employee names (i.e.: the name attribute) for employees in Employee having a salary greater than $2000 per month who have been employees for less than 10 months. Sort your result by ascending employee_id.
SELECT name FROM Employee WHERE salary > 2000 AND months < 10 ORDER BY employee_id;

--Q120.
----TRIANGLES table
create table if not exists TRIANGLES
(
    A int,
    B int,
    C int
);


insert into TRIANGLES VALUES (20,20,23),(20,20,20),(20,21,22),(13,14,30);

select * from TRIANGLES;


--Write a query identifying the type of each record in the TRIANGLES table using its three side lengths.
--Output one of the following statements for each record in the table:
--● Equilateral: It's a triangle with sides of equal length.
--● Isosceles: It's a triangle with sides of equal length.
--● Scalene: It's a triangle with sides of differing lengths.
--● Not A Triangle: The given values of A, B, and C don't form a triangle.
SELECT CASE
WHEN A + B <= C OR A + C <= B OR B + C <= A THEN 'Not A Triangle'
WHEN A = B AND B = C THEN 'Equilateral'
WHEN A = B OR B = C OR A = C THEN 'Isosceles'
ELSE 'Scalene'
END
FROM TRIANGLES;



--Q121.
--user_transactions Table:
create table if not exists user_transactions
(
    transaction_id int,
    product_id int,
    spend decimal,
    transaction_date DATETIME
);

insert into user_transactions VALUES (1341,123424,1500.60,'12/31/2019 12:00:00'),(1423,123424,1000.20,'12/31/2020 12:00:00')(1623,123424,1246.44,'12/31/2021 12:00:00')(1322,123424,2145.32,'12/31/2022 12:00:00');

select * from user_transactions;

--Write a query to obtain the year-on-year growth rate for the total spend of each product for each year.



--Q122.
--inventory table:
create table if not exists inventory
(
    item_id int,
    item_type VARCHAR(50),
    item_category VARCHAR(50),
    square_footage DECIMAL
);

insert into inventory VALUES (1374,'prime_eligible','mini refrigerator',68.00),(4245,'not_prime','standing lamp',26.40),(2452,'prime_eligible','television',85.00),(3255,'not_prime','side table',22.60),(1672,'prime_eligible','laptop',8.50);

select * from inventory;

--Write a SQL query to find the number of prime and non-prime items that can be stored in the 500,000 square feet warehouse. Output the item type and number of items to be stocked.
SELECT
  item_type,
  SUM(square_footage) AS total_sqft,
  COUNT(*) AS item_count
FROM inventory
GROUP BY item_type;



--Q123.
--user_actions Table:
create table if not exists user_actions
(
    user_id int,
    event_id int,
    event_type enum ("sign-in", "like", "comment"),
    event_date DATETIME
);

insert into user_actions VALUES (445,7765,'sign-in','05/31/2022 12:00:00'),(742,6458,'sign-in','06/03/2022 12:00:00'),(445,3634,'like','06/05/2022 12:00:00'),(742,1374,'comment','06/05/2022 12:00:00'),(648,3124,'like','06/18/2022 12:00:00');

select * from user_actions;

--Write a query to obtain the active user retention in July 2022. Output the month (in numerical format 1, 2, 3) and the number of monthly active users (MAUs).

SELECT 
  EXTRACT(MONTH FROM curr_month.event_date) AS mth, 
  COUNT(DISTINCT curr_month.user_id) AS monthly_active_users 
FROM user_actions AS curr_month
WHERE EXISTS (
  SELECT last_month.user_id 
  FROM user_actions AS last_month
  WHERE last_month.user_id = curr_month.user_id
    AND EXTRACT(MONTH FROM last_month.event_date) =
    EXTRACT(MONTH FROM curr_month.event_date - interval '1 month')
)
  AND EXTRACT(MONTH FROM curr_month.event_date) = 7
  AND EXTRACT(YEAR FROM curr_month.event_date) = 2022
GROUP BY EXTRACT(MONTH FROM curr_month.event_date);



--Q124.
--search_frequency Table:
create table if not exists search_frequency
(
    searches int,
    num_users int
);


insert into search_frequency VALUES (1,2),(2,2),(3,3),(4,1);

select * from search_frequency;


--Write a query to report the median of searches made by a user. Round the median to one decimal point
WITH RECURSIVE cte AS (
  SELECT searches, num_users as NU FROM search_frequency

UNION ALL
  
SELECT cte.searches,
cte.NU - 1
FROM cte WHERE NU > 0
)

select PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY searches) AS median FROM cte
WHERE nu > 0;


--Q125.
--advertiser Table:
create table if not exists advertiser
(
    user_id VARCHAR(50),
    status VARCHAR(50)
);


insert into advertiser VALUES ('bing','NEW'),('yahoo','NEW'),('alibaba','EXISTING');

select * from advertiser;

--daily_pay Table:
create table if not exists daily_pay
(
    user_id VARCHAR(50),
    paid decimal
);

insert into daily_pay VALUES ('yahoo',45.00),('alibaba',100.00),('target',13.00);

select * from daily_pay;

--Write a query to update the Facebook advertiser's status using the daily_pay table. Advertiser is  two-column table containing the user id and their payment status based on the last payment an daily_pay table has current information about their payment. Only advertisers who paid will show up in this table.Output the user id and current payment status sorted by the user id.

WITH payment_status AS (
SELECT
  advertiser.user_id,
  advertiser.status,
  payment.paid
FROM advertiser
LEFT JOIN daily_pay AS payment
  ON advertiser.user_id = payment.user_id

UNION

SELECT
  payment.user_id,
  advertiser.status,
  payment.paid
FROM daily_pay AS payment
LEFT JOIN advertiser
  ON advertiser.user_id = payment.user_id
)

SELECT
  user_id,
  CASE WHEN paid IS NULL THEN 'CHURN'
  	WHEN status != 'CHURN' AND paid IS NOT NULL THEN 'EXISTING'
  	WHEN status = 'CHURN' AND paid IS NOT NULL THEN 'RESURRECT'
  	WHEN status IS NULL THEN 'NEW'
  END AS new_status
FROM payment_status
ORDER BY user_id;


--Q126.

--server_utilization Table:
create table if not exists server_utilization
(
    server_id int,
    status_time TIMESTAMP,
    session_status VARCHAR(50)
);

insert into server_utilization VALUES(1,'08/02/2022 10:00:00','start'),(1,'08/04/2022 10:00:00','stop  '),(2,'08/17/2022 10:00:00','start'),(2,'08/24/2022 10:00:00','stop');


select * from server_utilization;

--Write a query that calculates the total time that the fleet of servers was running. The output should be in units of full days.



--Q127.
--transactions
create table if not exists transactions
(
    transaction_id int,
    merchant_id int,
    credit_card_id INT,
    amount int,
    transaction_timestamp datetime
);


insert into transactions values (1,101,1,100,'09/25/2022 12:00:00'),(2,101,1,100,'09/25/2022'),(3,101,1,100,'09/25/2022 12:28:00'),(4,102,2,300,'09/25/2022 12:00:00'),(6,102,2,400,'09/25/2022 14:00:00');

select * from transactions;

--Sometimes, payment transactions are repeated by accident; it could be due to user error, API failure or a retry error that causes a credit card to be charged twice. Using the transactions table, identify any payments made at the same merchant with the same credit card for the same amount within 10 minutes of each other. Count such repeated payments.
WITH payments AS (
  SELECT 
    merchant_id, 
    EXTRACT(EPOCH FROM transaction_timestamp - 
      LAG(transaction_timestamp) OVER(
        PARTITION BY merchant_id, credit_card_id, amount 
        ORDER BY transaction_timestamp)
    )/60 AS minute_difference 
  FROM transactions) 

SELECT COUNT(merchant_id) AS payment_count
FROM payments 
WHERE minute_difference <= 10;


--Q128
--orders Table:
create table if not exists orders
(
    order_id int,
    customer_id int,
    trip_id INT,
    status enum ('completed,successfully','completed incorrectly', 'never received'),
    order_timestamp timestamp
);

insert into orders VALUES (727424,8472,100463,'completed successfully','06/05/2022 09:12:00'),(242513,2341,100482,'completed incorrectly','06/05/2022 14:40:00'),(141367,1314,100362,'completed incorrectly','06/07/2022 15:03:00'),(582193,5421,100657,'never_received','07/07/2022 15:22:00'),(253613,1314,100213,'completed successfully','06/12/2022 13:43:00');


select * from orders;

--trips Table:
create table if not exists trips
(
    dasher_id int,
    trip_id int,
    estimated_delivery_timestamp timestamp,
    actual_delivery_timestamp timestamp
);

insert into trips VALUES (101,100463,'06/05/2022 09:42:00','06/05/2022 09:38:00'),(102,100482,'06/05/2022 15:10:00','06/05/2022 15:46:00'),(101,100362,'06/07/2022 15:33:00','06/07/2022 16:45:00'),(102,100657,'07/07/2022 15:52:00','-'),(103,100213,'06/12/2022 14:13:00','06/12/2022 14:10:00');

select * from trips;

--customers Table:
create table if not exists customers
(
    customer_id int,
    signup_timestamp timestamp
);

insert into customers VALUES (8472,'05/30/2022 00:00:00'),(2341,'06/01/2022 00:00:00'),(1314,'06/03/2022 00:00:00'),(1435,'06/05/2022 00:00:00'),(5421,'06/07/2022 00:00:00');

select * from customers;

--Write a query to find the bad experience rate in the first 14 days for new users who signed up in June 2022. Output the percentage of bad experience rounded to 2 decimal places.



--Q129.
-- Scores
create table if not exists Scores
(
    player_name VARCHAR(50),
    gender VARCHAR(50),
    day DATE,
    score_points int,
    constraint pk PRIMARY KEY (gender, day)
);

insert into Scores VALUES ('Aron','F','2020-01-01',17),('Alice','F','2020-01-07',23),('Bajrang','M','2020-01-07',7),('Khali','M','2019-12-25',11),('Slaman','M','2019-12-30',13),('Joe','M','2019-12-31',3),('Jose','M','2019-12-18',2),('Priya','F','2019-12-31',23),('Priyanka','F','2019-12-30',17);


--Write an SQL query to find the total score for each gender on each day. Return the result table ordered by gender and day in ascending order. The query result format is in the following example.
select s1.gender, s1.day, sum(s2.score_points) as total from Scores s1, Scores s2
where s1.gender = s2.gender and s1.day >= s2.day
group by s1.gender, s1.day
order by s1.gender, s1.day;


--Q130.
--Table Person:
create table if not exists Person
(
    id int,
    name VARCHAR(50),
    phone_number VARCHAR(50),
    constraint pk PRIMARY KEY (id)
);

insert into Person VALUES (3,'Jonathan','051-1234567'),(12,'Elvis','051-7654321'),(1,'Moncef','212-1234567'),(2,'Maroua','212-6523651'),(7,'Meir','972-1234567'),(9,'Rachel','972-0011100');

select * from Person;

--Country table:
create table if not exists Country
(
    name VARCHAR(50),
    country_code VARCHAR(50),
    constraint pk PRIMARY KEY (country_code)
);

insert into Country VALUES ('Peru',51),('Israel',972),('Morocco',212),('Germany',49),('Ethiopia',251);

select * from Country;

--Table Calls:
create table if not exists Calls
(
    caller_id int,
    callee_id int,
    duration int
);

insert into Calls VALUES (1,9,33),(2,9,4),(1,2,59),(3,12,102),(3,12,330),(12,3,5),(7,9,13),(7,1,3),(9,7,1),(1,7,7);

select * from Calls;

--Write an SQL query to find the countries where this company can invest.
--Return the result table in any order.
SELECT
 co.name AS country
FROM
 Person p
 JOIN
     Country co
     ON SUBSTRING(phone_number,1,3) = country_code
 JOIN
     Calls c
     ON p.id IN (c.caller_id, c.callee_id)
GROUP BY
 co.name
HAVING
 AVG(duration) > (SELECT AVG(duration) FROM Calls);



--Q131.
--Table: Numbers
create table if not exists Numbers
(
    num int,
    frequency int,
    constraint pk PRIMARY KEY (num)
);

drop table Numbers;
insert into Numbers VALUES (0,7),(1,1),(2,3),(3,1);

select * from Numbers;

--Write an SQL query to report the median of all the numbers in the database after decompressing the Numbers table. Round the median to one decimal point.
with recursive rec_cte as
(
select num,frequency,1 asc cnt
    from Numbers 
    UNION
select num,frequency,cnt+1 as cnt 
    from rec_cte
where cnt < frequency
),
med_cte as 
(
    SELECT num,frequency,cnt,
    row_number() over (order by num) row_num,
    count(*) over () tot_count
    from rec_cte
)
select case when MOD(tot_count,2) = 0 then round(avg(num),1) 
else round(num,1) end as median
from med_cte 
where row_num BETWEEN 
tot_count/2 and tot_count/2+1;


--Q132.
--Table: Salary
create table if not exists Salary
(
    id int,
    employee_id int,
    amount int,
    pay_date date,
    constraint pk PRIMARY KEY (id)
);

insert into Salary VALUES (1,1,9000,'2017/03/31'),(2,2,6000,'2017/03/31'),(3,3,10000,'2017/03/31'),(4,1,7000,'2017/02/28'),(5,2,6000,'2017/02/28'),(6,3,8000,'2017/02/28');

select * from Salary;

--Employee table:
create table if not exists Employee
(
    employee_id int,
    department_id int,
    constraint pk PRIMARY KEY (employee_id)
);

insert into Employee VALUES (1,1),(2,2),(3,2);

select * from Employee;

--Write an SQL query to report the comparison result (higher/lower/same) of the average salary of employees in a department to the company's average salary. Return the result table in any order.
select 
    pay_month,
    department_id, 
    case when dept_avg > comp_avg then 'higher' when dept_avg < comp_avg then 'lower' else 'same' end comparison
from (
        select  date_format(b.pay_date, '%Y-%m') pay_month, a.department_id, avg(b.amount) dept_avg,  d.comp_avg
        from Employee a 
        inner join Salary b
            on (a.employee_id = b.employee_id) 
        inner join (select date_format(c.pay_date, '%Y-%m') pay_month, avg(c.amount) comp_avg 
                    from Salary c 
                    group by date_format(c.pay_date, '%Y-%m')) d 
            on ( date_format(b.pay_date, '%Y-%m') = d.pay_month)
group by date_format(b.pay_date, '%Y-%m'), department_id, d.comp_avg) final;


--Q133.
--Table: Activity
create table if not exists Activity
(
    player_id int,
    device_id int,
    event_date date,
    games_played int,
    constraint pk PRIMARY KEY (player_id, event_date)
);


insert INTO Activity VALUES (1,2,'2016-03-01',5),(1,2,'2016-03-02',6),(2,3,'2017-06-25',1),(3,1,'2016-03-01',0),(3,4,'2016-07-03',5);


select * from Activity;

--Write an SQL query to report for each install date, the number of players that installed the game on that day, and the day one retention.Return the result table in any order.

select a1.event_date as install_dt, count(a1.player_id) as installs, round(count(a3.player_id) / count(a1.player_id), 2) as Day1_retention
    from Activity a1 left join Activity a2
    on a1.player_id = a2.player_id and a1.event_date > a2.event_date
    left join Activity a3
    on a1.player_id = a3.player_id and datediff(a3.event_date, a1.event_date) = 1
    where a2.event_date is null
    group by a1.event_date;


--Q134.
--Table: Players
create table if not exists Players
(
    player_id int,
    group_id int,
    constraint pk PRIMARY KEY (player_id)
);

insert into Players VALUES (15,1), (25,1), (30,1), (45,1), (10,2), (35,2), (50,2), (20,3), (40,3);

select * from Players;

--Table: Matches
create table if not exists Matches
(
    match_id int,
    first_player int,
    second_player int,
    first_score int,
    second_score int,
    constraint pk PRIMARY KEY (match_id)
);

insert into Matches VALUES (1,15,45,3,0),(2,30,25,1,2),(3,30,15,2,0),(4,40,20,5,2),(5,35,50,1,1);

select * from Matches;

--Write an SQL query to find the winner in each group.
--Return the result table in any order.
select group_id, player_id from (
	select p.group_id, ps.player_id, sum(ps.score) as score
	from Players p,
	    (
            select first_player as player_id, first_score as score
            from Matches
            union all
            select second_player, second_score
            from Matches
	    ) ps
	where p.player_id = ps.player_id
	group by ps.player_id
	order by group_id, score desc, player_id
	-- limit 1 -- by default, groupby will pick the first one i.e. max score player here
) top_scores
group by group_id;


--Q135.
--Table: Student
create table if not exists Student
(
    student_id int,
    student_name VARCHAR(50),
    constraint pk PRIMARY KEY (student_id)
);


insert into Student VALUES (1,'Daniel'),(2,'Jade'),(3,'Stella'),(4,'Jonathan'),(5,'Will');

select * from Student;

--Table: Exam
create table if not exists Exam
(
    exam_id int,
    student_id int,
    score int,
    constraint pk PRIMARY KEY (exam_id, student_id)
);

insert into Exam VALUES (10,1,70),(10,2,80),(10,3,90),(20,1,80),(30,1,70),(30,3,80),(30,4,90),(40,1,60),(40,2,70),(40,4,80);

select * from Exam;


--Write an SQL query to report the students (student_id, student_name) being quiet in all exams. Do not return the student who has never taken any exam.Return the result table ordered by student_id.
select 
   Student.*
from Exam 
inner join Student on Student.student_id=Exam.student_id
group by student_id 
having max(score) not in (select max(score) from Exam) 
   and min(score) not in (select min(score) from Exam);


--Q136.
--Table: Student
--Exam table:
--Write an SQL query to report the students (student_id, student_name) being quiet in all exams. Do not return the student who has never taken any exam.Return the result table ordered by student_id.
select 
   Student.*
from Exam 
inner join Student on Student.student_id=Exam.student_id
group by student_id 
having max(score) not in (select max(score) from Exam) 
   and min(score) not in (select min(score) from Exam);


--Q137.
--Table: UserActivity
create table if not exists UserActivity
(
    username VARCHAR(50),
    activity varchar(50),
    startDate date,
    endDate date
);

insert INTO UserActivity VALUES ('Alice','Travel','2020-02-12','2020-02-20'),('Alice','Dancing','2020-02-21','2020-02-23'),('Alice','Travel','2020-02-24','2020-02-28'),('Bob','Travel','2020-02-11','2020-02-18');

select * from UserActivity;

--Write an SQL query to show the second most recent activity of each user.If the user only has one activity, return that one. A user cannot perform more than one activity at the same time.Return the result table in any order.
select distinct username, activity, startDate, endDate
from
    (select u.*,
           rank() over (partition by username order by startDate desc) as rnk,
           count(activity) over (partition by username) as num
    from UserActivity u) t
where (num <> 1 and rnk = 2) or (num = 1 and rnk = 1);


--Q138.
--Table: UserActivity

--Write an SQL query to show the second most recent activity of each user.If the user only has one activity, return that one. A user cannot perform more than one activity at the same time. Return the result table in any order.
select distinct username, activity, startDate, endDate
from
    (select u.*,
           rank() over (partition by username order by startDate desc) as rnk,
           count(activity) over (partition by username) as num
    from UserActivity u) t
where (num <> 1 and rnk = 2) or (num = 1 and rnk = 1);


--Q139.
--STUDENTS table
create table if not exists STUDENTS
(
    id int,
    name VARCHAR(50),
    marks int
);

insert into STUDENTS VALUES (1,'Ashley',81),(2,'Samantha',75),(4,'Julia',76),(3,'Belvet',84);

select * from STUDENTS;

--Query the Name of any student in STUDENTS who scored higher than 75 Marks. Order your output by the last three characters of each name. If two or more students both have names ending in the same last three characters (i.e.: Bobby, Robby, etc.), secondary sort them by ascending ID.
SELECT NAME FROM STUDENTS WHERE MARKS > 75 ORDER BY RIGHT(NAME,3), ID ASC;



--Q140.
--Employee table
 create table if not exists Employee
(
    employee_id int,
    name VARCHAR(50),
    months int,
    salary int
);

insert into Employee VALUES (12228,'Rose',15,1968),(33645,'Angela',1,3443),(45692,'Frank',17,1608),(56118,'Patrick',7,1345),(59725,'Lisa',11,2330),(74197,'Kimberly',16,4372),(78454,'Bonnie',8,1771),(83565,'Michael',6,2017),(98607,'Todd',5,3396),(99989,'Joe',9,3573);

select * from Employee;

--Write a query that prints a list of employee names (i.e.: the name attribute) from the Employee table in alphabetical order.
SELECT name FROM Employee ORDER BY name;


--Q141.
--Write a query that prints a list of employee names (i.e.: the name attribute) for employees in Employee having a salary greater than $2000 per month who have been employees for less than 10 months. Sort your result by ascending employee_id.
SELECT name FROM Employee WHERE salary > 2000 AND months < 10 ORDER BY employee_id;



--Q142.
--TRIANGLES table
create table if not exists TRIANGLES
(
    A int,
    B int,
    C int
);


insert into TRIANGLES VALUES (20,20,23),(20,20,20),(20,21,22),(13,14,30);

select * from TRIANGLES;


--Write a query identifying the type of each record in the TRIANGLES table using its three side lengths.
--Output one of the following statements for each record in the table:
--● Equilateral: It's a triangle with sides of equal length.
--● Isosceles: It's a triangle with sides of equal length.
--● Scalene: It's a triangle with sides of differing lengths.
--● Not A Triangle: The given values of A, B, and C don't form a triangle.
SELECT CASE
WHEN A + B <= C OR A + C <= B OR B + C <= A THEN 'Not A Triangle'
WHEN A = B AND B = C THEN 'Equilateral'
WHEN A = B OR B = C OR A = C THEN 'Isosceles'
ELSE 'Scalene'
END
FROM TRIANGLES;


--Q143.
--EMPLOYEES table
create table if not exists EMPLOYEES
(
    id int,
    name VARCHAR(50),
    salary int
);


insert into EMPLOYEES VALUES (1,'Kristeen',1420), (2,'Ashley',2006), (3,'Julia',2210), (4,'Maria',3000);

select * from EMPLOYEES;

--Write a query calculating the amount of error (i.e.: actual - miscalculated average monthly salaries), and round it up to the next integer.
select ceil(avg(salary) - avg(replace(salary, '0', ''))) from EMPLOYEES;


--Q144.
--Employee table
 create table if not exists Employee
(
    employee_id int,
    name VARCHAR(50),
    months int,
    salary int
);

insert into Employee VALUES (12228,'Rose',15,1968),(33645,'Angela',1,3443),(45692,'Frank',17,1608),(56118,'Patrick',7,1345),(59725,'Lisa',11,2330),(74197,'Kimberly',16,4372),(78454,'Bonnie',8,1771),(83565,'Michael',6,2017),(98607,'Todd',5,3396),(99989,'Joe',9,3573);

select * from Employee;

--Write a query to find the maximum total earnings for all employees as well as the total number ofemployees who have maximum total earnings. Then print these values as 2 space-separated integers.
 select MAX(salary*months), COUNT(*) from Employee where (salary * months) >= (select MAX(salary * months) from Employee);


--Q145.
--OCCUPATIONS table
create table if not exists OCCUPATIONS
(
    Name VARCHAR(50),
    Occupation VARCHAR(50)
);


insert into OCCUPATIONS VALUES ('Samantha','Doctor'),('Julia','Actor'),('Maria','Actor'),('Meera','Singer'),('Ashely','Professor'),('Ketty','Professor'),('Christeen','Professor'),('Jane','Actor'),('Jenny','Doctor'),('Priya','Singer');

select * from OCCUPATIONS;

--Query the number of occurrences of each occupation in OCCUPATIONS. Sort the occurrences in ascending order,
(
  SELECT CONCAT(NAME, '(', SUBSTRING(Occupation, 1, 1), ')') as THETEXT, '1' as SELECTNUMBER
    FROM OCCUPATIONS
)
UNION ALL 
(
  SELECT CONCAT('There are total ', COUNT(*),' ', Occupation, (IF (COUNT(*) > 1, 's',''))) as THETEXT, '2' as SELECTNUMBER
   FROM OCCUPATIONS GROUP BY Occupation
)
ORDER BY SELECTNUMBER ASC, THETEXT ASC;


--Q146 .
--Pivot the Occupation column in OCCUPATIONS so that each Name is sorted alphabetically and displayed underneath its corresponding Occupation. The output column headers should be Doctor, Professor, Singer, and Actor, respectively.
select
    Doctor,
    Professor,
    Singer,
    Actor
from (
    select
        NameOrder,
        max(case Occupation when 'Doctor' then Name end) as Doctor,
        max(case Occupation when 'Professor' then Name end) as Professor,
        max(case Occupation when 'Singer' then Name end) as Singer,
        max(case Occupation when 'Actor' then Name end) as Actor
    from (
            select
                Occupation,
                Name,
                row_number() over(partition by Occupation order by Name ASC) as NameOrder
            from OCCUPATIONS
         ) as NameLists
    group by NameOrder
    ) as Names;



--Q147.
--BST TABLE
create table if not exists BST
(
    N int,
    P int
);

insert into BST VALUES(1,2),(3,2),(6,8),(9,8),(2,5),(8,5),(5,null);

select * from BST;


--Write a query to find the node type of Binary Tree ordered by the value of the node. Output one of the following for each node:
--● Root: If node is root node.
--● Leaf: If node is leaf node.
--● Inner: If node is neither root nor leaf node.

SELECT N,
CASE
WHEN P IS NULL THEN 'Root'
WHEN N IN (SELECT P FROM BST) THEN 'Inner'
ELSE 'Leaf'
END
FROM BST
ORDER by N;



--Q148 .

--Given the table schemas below, write a query to print the company_code, founder name, total number of lead managers, total number of senior managers, total number of managers, and total number of employees. Order your output by ascending company_code.

--Company
create table if not exists Company
(
    company_code  VARCHAR(50),
    founder VARCHAR(50)
);

insert into Company VALUES ('C1','Monika'),('C2','Samantha');

select * from Company;

--Lead_Manager
create table if not exists Lead_Manager
(
    lead_manager_code  VARCHAR(50),
    company_code VARCHAR(50)
);

insert into Lead_Manager VALUES ('LM1','C1'),('LM2','C2');

select * from Lead_Manager;


--Senior_Manager
create table if not exists Senior_Manager
(
    senior_manager_code  VARCHAR(50),
    lead_manager_code VARCHAR(50),
    company_code VARCHAR(50)
);

insert into Senior_Manager VALUES ('SM1','LM1','C1'),('SM2','LM1','C1'),('SM3','LM2','C2');

select * from Senior_Manager;

--Manager Table:
create table if not exists Manager
(
    manager_code  VARCHAR(50),
    senior_manager_code VARCHAR(50),
    lead_manager_code VARCHAR(50),
    company_code VARCHAR(50)
);

insert into Manager VALUES ('M1','SM1','LM1','C1'),('M2','SM3','LM2','C2'),('M3','SM3','LM2','C2');

select * from Manager;

--Employee:
create table if not exists Employee
(
    employee_code  VARCHAR(50),
    manager_code VARCHAR(50),
    senior_manager_code VARCHAR(50),
    lead_manager_code VARCHAR(50),
    company_code VARCHAR(50)
);

insert into Employee VALUES ('E1','M1','SM1','LM1','C1'),('E2','M1','SM1','LM1','C1'),('E3','M2','SM3','LM2','C2'),('E4','M3','SM3','LM2','C2');

select * from Employee;

SELECT c.company_code, c.founder, COUNT(DISTINCT e.lead_manager_code), COUNT(DISTINCT e.senior_manager_code), COUNT(DISTINCT e.manager_code), COUNT(DISTINCT e.employee_code) FROM Company c
JOIN Employee e ON c.company_code = e.company_code GROUP BY c.company_code, c.founder ORDER BY c.company_code;



--Q149 .
--Functions table
create table if not exists Functions
(
    X int,
    Y int
);

insert into Functions VALUES (20,20),(20,20),(20,21),(23,22),(22,23),(21,20);

select * from Functions;

--Write a query to output all such symmetric pairs in ascending order by the value of X. List the row such that X1 ≤ Y1.


SELECT f1.X, f1.Y FROM Functions AS f1 
WHERE f1.X = f1.Y AND
(SELECT COUNT(*) FROM Functions WHERE X = f1.X AND Y = f1.Y) > 1
UNION
SELECT f1.X, f1.Y from Functions AS f1
WHERE EXISTS(SELECT X, Y FROM Functions WHERE f1.X = Y AND f1.Y = X AND f1.X < X)
ORDER BY X;



--Q150 .
--Students TABLE
create table if not exists Students
(
    id int,
    name VARCHAR(50)
);

insert into Students VALUES (1,'Ashley'),(2,'Samantha'),(3,'Julia'),(4,'Scarlet');

select * from Students;

--Friends TABLE
create table if not exists Friends
(
    id int,
    friend_id int
);

insert into Friends VALUES (1,2),(2,3),(3,4),(4,1);

select * from Friends;

--Packages. TABLE
create table if not exists Packages
(
    id int,
    salary float
);

insert into Packages VALUES (1,15.20),(2,10.06),(3,11.55),(4,12.12);

select * from Packages;


--Write a query to output the names of those students whose best friends got offered a higher salary than them. Names must be ordered by the salary amount offered to the best friends. It is guaranteed that no two students get the same salary offer.

select S1.name
from Students s1 
inner join Packages p1 on s1.id = p1.id
inner join Friends f on s1.id = f.id
inner join Students s2 on f.friend_id = s2.id
inner join Packages p2 on s2.id = p2.id
where p1.salary < p2.salary
order by p2.salary; 


--Q151.
--Hackers table:
create table if not exists Hackers
(
    hacker_id int,
    name VARCHAR(50)
);

insert into Hackers VALUES (5580,'Rose'),(8439,'Angela'),(27205,'Frank'),(52243,'Patrick'),(52348,'Lisa'),(57645,'Kimberly'),(77726,'Bonnie'),(83082,'Michael'),(86870,'Todd'),(90411,'Joe');

select * from Hackers;



--Difficulty: table:
create table if not exists Difficulty
(
    difficulty_level int,
    score int
);


insert into Difficulty VALUES (1,20),(2,30),(3,40),(4,60),(5,80),(6,100),(7,120);

select * from Difficulty;



--Challenges table:
create table if not exists Challenges
(
    challenge_id int,
    hacker_id int,
    difficulty_level int
);


insert into Challenges VALUES (4810,77726,4),(21089,27205,1),(36566,5580,7),(66730,52243,6),(71055,52243,2);

select * from Challenges;



--Submissions table:
create table if not exists Submissions
(
    submission_id int,
    hacker_id int,
    challenge_id int,
    score int
);

insert into Submissions VALUES (68628,77726,36566,30),(65300,77726,21089,10),(40326,52243,36566,77),(8941,27205,4810,4),(83554,77726,66730,30),(97397,90411,4810,40),(84162,83082,4810,40),(97431,90411,71055,30);

select * from Submissions;


--Write a query to print the respective hacker_id and name of hackers who achieved full scores for more than one challenge. Order your output in descending order by the total number of challenges in which the hacker earned a full score. If more than one hacker received full scores in the same number of challenges, then sort them by ascending hacker_id.

SELECT S.hacker_id, name
FROM Submissions AS S
JOIN Hackers AS H ON S.hacker_id = H.hacker_id
JOIN Challenges AS C ON S.challenge_id = C.challenge_id
JOIN Difficulty AS D ON C.difficulty_level = D.difficulty_level
WHERE S.score = D.score
GROUP BY name, S.hacker_id
HAVING count(S.challenge_id) > 1
ORDER BY count(S.challenge_id) DESC, S.hacker_id;



--Q152.
--table Projects
create table if not exists Projects
(
    Task_ID int,
    Start_Date date,
    End_Date date
);

insert into Projects VALUES (1,'2015-10-01','2015-10-02'),(2,'2015-10-02','2015-10-03'),(3,'2015-10-03','2015-10-04'),(4,'2015-10-13','2015-10-14'),(5,'2015-10-14','2015-10-15'),(6,'2015-10-28','2015-10-29'),(7,'2015-10-30','2015-10-31');



--Write a query to output the start and end dates of projects listed by the number of days it took to complete the project in ascending order. If there is more than one project that have the same number of completion days, then order by the start date of the project.
Select Start_Date, MIN(End_Date)
From
    (Select b.Start_Date
    From Projects as a
    RIGHT Join Projects as b
    ON b.Start_Date = a.End_Date
    WHERE a.Start_Date IS NULL
    ) sd,
    (Select a.End_Date
    From Projects as a
    Left Join Projects as b
    ON b.Start_Date = a.End_Date
    WHERE b.End_Date IS NULL
    ) ed
Where Start_Date < End_Date
GROUP BY Start_Date
ORDER BY datediff(MIN(End_Date), Start_Date), Start_Date;


--Q153.
--transactions Table:
create table if not exists transactions
(
    user_id int,
    amount float,
    transaction_date TIMESTAMP
);

insert into transactions VALUES (1,9.99,'08/01/2022 10:00:00'),(1,55,'08/17/2022 10:00:00'),(2,149.5,'08/05/2022 10:00:00'),(2,4.89,'08/06/2022 10:00:00'),(2,34,'08/07/2022 10:00:00');

select * from transactions;

--In an effort to identify high-value customers, Amazon asked for your help to obtain data about users who go on shopping sprees. A shopping spree occurs when a user makes purchases on 3 or more consecutive days. List the user IDs who have gone on at least 1 shopping spree in ascending order.



--Q154 .
--payments Table:
--You are given a table of PayPal payments showing the payer, the recipient, and the amount paid. A two-way unique relationship is established when two people send money back and forth. Write a query to find the number of two-way unique relationships in this data.Assumption:
--A payer can send money to the same recipient multiple times.
create table if not exists payments
(
    payer_id int,
    recipient_id int,
    amount int
);

insert into payments VALUES (101,201,30), (201,101,10), (101,301,20), (301,101,80), (201,301,70);

select * from payments;

WITH T1 AS 
  (SELECT
   payer_id,
   recipient_id
  FROM payments
  INTERSECT
  SELECT
   recipient_id,
   payer_id
  FROM payments)

SELECT
 COUNT(payer_id)/2 AS UNIQUE_RELATIONSHIPS
FROM
 T1;


--Q155 .
--user_logins Table:

create table if not exists user_logins
(
    user_id int,
    login_date DATETIME
);

insert into user_logins VALUES (725,'03/03/2022 12:00:00'), (245,'03/28/2022 12:00:00'), (112,'03/05/2022 12:00:00'), (245,'04/29/2022 12:00:00'), (112,'04/05/2022 12:00:00');

select * from user_logins;

--Assume you are given the table below containing information on Facebook user logins. Write a query to obtain the number of reactivated users (which are dormant users who did not log in the previous month, then logged in during the current month).Output the current month (in numerical) and number of reactivated users.



--Q156.
--user_transactions Table:
create table if not exists user_transactions
(
    transaction_id int,
    product_id int,
    spend decimal (5,2),
    transaction_date DATETIME
);

insert into user_transactions VALUES (759274,111,49.50,'02/03/2022 00:00:00'),(850371,111,51.00,'03/15/2022 00:00:00'),(615348,145,36.30,'03/22/2022 00:00:00'),(137424,156,151.00,'04/04/2022 00:00:00'),(248475,156,87.00,'04/16/2022 00:00:00');

select * from user_transactions;

--Write a query to obtain the list of customers whose first transaction was valued at $50 or more. Output the number of users.



--Q157.
--measurements Table:
create table if not exists measurements
(
    measurement_id int,
    measurement_value DECIMAL,
    measurement_time datetime
);

insert into measurements VALUES (131233,1109.51,'07/10/2022 09:00:00'), (135211,1662.74,'07/10/2022 11:00:00'), (523542,1246.24,'07/10/2022 13:15:00'), (143562,1124.50,'07/11/2022 15:00:00'), (346462,1234.14,'07/11/2022 16:45:00');

select * from measurements;


--Write a query to obtain the sum of the odd-numbered and even-numbered measurements on a particular day, in two different columns.
WITH ranked_measurements AS (
  SELECT 
    CAST(measurement_time AS DATE) AS measurement_day, 
    measurement_value, 
    ROW_NUMBER() OVER (
      PARTITION BY CAST(measurement_time AS DATE) 
      ORDER BY measurement_time) AS measurement_num 
  FROM measurements
) 

SELECT 
  measurement_day, 
  SUM(
    CASE WHEN measurement_num % 2 != 0 THEN measurement_value 
      ELSE 0 END) AS odd_sum, 
  SUM(
  CASE WHEN measurement_num % 2 = 0 THEN measurement_value 
    ELSE 0 END) AS even_sum 
FROM ranked_measurements
GROUP BY measurement_day;




--Q158.
--transactions Table:
--transactions Table:
create table if not exists transactions
(
    user_id int,
    amount float,
    transaction_date TIMESTAMP
);

insert into transactions VALUES (1,9.99,'08/01/2022 10:00:00'),(1,55,'08/17/2022 10:00:00'),(2,149.5,'08/05/2022 10:00:00'),(2,4.89,'08/06/2022 10:00:00'),(2,34,'08/07/2022 10:00:00');

select * from transactions;

--In an effort to identify high-value customers, Amazon asked for your help to obtain data about users who go on shopping sprees. A shopping spree occurs when a user makes purchases on 3 or more consecutive days. List the user IDs who have gone on at least 1 shopping spree in ascending order.


--Q159.
--rental_amenities Table:
create table if not exists rental_amenities
(
    rental_id int,
    amenity VARCHAR(50)
);

insert into rental_amenities VALUES (123,'pool'), (123,'kitchen'), (234,'hot tub'), (234,'fireplace'), (345,'kitchen'), (345,'pool'), (456,'pool');

select * from rental_amenities;

--write a query to find the unique combination of two Airbnb rentals with the same exact amenities offered.



--Q160.
--ad_campaigns Table:
create table if not exists ad_campaigns
(
    campaign_id int,
    spend int,
    revenue FLOAT,
    advertiser_id int
);

insert into ad_campaigns VALUES (1,500,7500,3), (2,1000,900,1),(3,3000,12000,2),(4,500,2000,4),(5,100,400,4);

select * from ad_campaigns;

--Write a query to calculate the return on ad spend (ROAS) for each advertiser across all ad campaigns. Round your answer to 2 decimal places, and order your output by the advertiser_id.
select advertiser_id, round(cast(sum(revenue)/sum(spend) as numeric),2) as ROAS
from ad_campaigns 
group by advertiser_id
order by advertiser_id;


--Q161.
--employee_pay Table:
create table if not exists employee_pay
(
    employee_id int,
    salary int,
    title VARCHAR(50)
);

insert into employee_pay VALUES (101,80000,'Data Analyst'), (102,90000,'Data Analyst'),(103,100000,'Data Analyst'),(104,30000,'Data Analyst'),(105,120000,'Data Scientist'),(106,100000,'Data Scientist'),(107,80000,'Data Scientist'),(108,310000,'Data Scientist');

select * from employee_pay;


--Write a query that shows the following data for each compensation outlier: employee ID, salary, and whether they are potentially overpaid or potentially underpaid (refer to Example Output below).




--Q162.
--payments table
create table if not exists payments
(
    payer_id int,
    recipient_id int,
    amount int
);

insert into payments VALUES (101,201,30), (201,101,10), (101,301,20), (301,101,80), (201,301,70);

select * from payments;

WITH T1 AS 
  (SELECT
   payer_id,
   recipient_id
  FROM payments
  INTERSECT
  SELECT
   recipient_id,
   payer_id
  FROM payments)

SELECT
 COUNT(payer_id)/2 AS UNIQUE_RELATIONSHIPS
FROM
 T1;


--Q163.
--purchases Table:

create table if not exists purchases
(
    user_id int,
    product_id int,
    quantity int,
    purchase_date DATETIME
);

insert into purchases VALUES (536,3223,6,'01/11/2022 12:33:44'),(827,3585,35,'02/20/2022 14:05:26'),(536,3223,5,'03/02/2022 09:33:28'),(536,1435,10,'03/02/2022 08:40:00'),(827,2452,45,'04/09/2022 00:00:00');

select * from purchases;

--Write a query to obtain the number of users who purchased the same product on two or more different days. Output the number of unique users.




--Q164.
--search_category Table:
create table if not exists search_category
(
    country VARCHAR(50),
    search_cat VARCHAR(50),
    num_search int,
    invalid_result_pct DECIMAL
);

insert into search_category VALUES ('UK','home',null,null),('UK','tax',98000,1.00),('UK','travel',100000,3.25);

select * from search_category;
--Write a query to obtain the percentage of invalid searches.Output the country in ascending order, total searches and overall percentage of invalid searches rounded to 2 decimal places.



--Q165.
--transactions Table:
create table if not exists transactions
(
    transaction_id VARCHAR(50),
    type enum('deposit','withdrawal'),
    amount DECIMAL,
    transaction_date DATETIME
);

insert into transactions VALUES (19153,'deposit',65.90,'07/10/2022 10:00:00'),(53151,'deposit',178.55,'07/08/2022 10:00:00'),(29776,'withdrawal',25.90,'07/08/2022 10:00:00'),(16461,'withdrawal',45.99,'07/08/2022 10:00:00'),(77134,'deposit',32.60,'07/10/2022 10:00:00');

select * from transactions;

--Write a query to print the cumulative balance of the merchant account at the end of each day, with the total balance reset back to zero at the end of the month. Output the transaction date and cumulative balance.




--Q166.
--product_spend Table:

create table if not exists product_spend
(
    category VARCHAR(50),
    product VARCHAR(50),
    user_id int,
    spend int,
    transaction_date TIMESTAMP
);

insert into product_spend VALUES ('appliance','refrigerator',165,246.00,'12/26/2021 12:00:00'),('appliance','refrigerator',123,299.99,'03/02/2022 12:00:00'),('appliance','washing machine',123,219.80,'03/02/2022 12:00:00'),('electronics','vacuum',178,152.00,'04/05/2022 12:00:00'),('electronics','wireless headset',156,249.90,'07/08/2022 12:00:00'),('electronics','vacuum',145,189.00,'07/15/2022 12:00:00');

select * from product_spend;

--Identify the top two highest-grossing products within each category in 2022. Output the category, product, and total spend.
SELECT 
  category, 
  product, 
  total_spend 
FROM (
    SELECT 
      *, 
      RANK() OVER (
        PARTITION BY category 
        ORDER BY total_spend DESC) AS ranking 
    FROM (
        SELECT 
          category, 
          product, 
          SUM(spend) AS total_spend 
        FROM product_spend 
        WHERE transaction_date >= '2022-01-01' 
          AND transaction_date <= '2022-12-31' 
        GROUP BY category, product) AS total_spend
  ) AS top_spend 
WHERE ranking <= 2 
ORDER BY category, ranking;


--Q167.
--users Table:
create table if not exists users
(
    user_id int,
    signup_date DATETIME,
    last_login DATETIME
);

insert into users VALUES (1001,'06/01/2022 12:00:00','07/05/2022 12:00:00'),(1002,'06/03/2022 12:00:00','06/15/2022 12:00:00'),(1004,'06/02/2022 12:00:00','06/15/2022 12:00:00'),(1006,'06/15/2022 12:00:00','07/05/2022 12:00:00'),(1012,'06/16/2022 12:00:00','07/22/2022 12:00:00');

select * from users;

--Write a query to generate the churn rate by week in June 2022. Output the week number (1, 2, 3, 4, ...) and the corresponding churn rate rounded to 2 decimal places.



--Q168.
--songs_history Table:
create table if not exists songs_history
(
    history_id int,
    user_id int,
    song_id int,
    song_plays int
);

insert into songs_history VALUES (10011,777,1238,11),(12452,695,4520,1);

select * from songs_history;


--songs_weekly Table:
create table if not exists songs_weekly
(
    user_id int,
    song_id int,
    listen_time DATETIME
);

insert into songs_weekly VALUES (777,1238,'08/01/2022 12:00:00'),(695,4520,'08/04/2022 08:00:00'),(125,9630,'08/04/2022 16:00:00'),(695,9852,'08/07/2022 12:00:00');

select * from songs_weekly;

--Write a query to output the user id, song id, and cumulative count of song plays as of 4 August 2022 sorted in descending order.
SELECT user_id, song_id, SUM(song_plays) AS song_count
FROM (
  SELECT user_id, song_id, song_plays
  FROM songs_history
  UNION ALL
  SELECT user_id, song_id, COUNT(song_id) AS song_plays
  FROM songs_weekly
  WHERE listen_time <= '08/04/2022 23:59:59'
  GROUP BY user_id, song_id
) AS report
GROUP BY user_id, song_id
ORDER BY song_count DESC;



--Q169.
--emails Table:
create table if not exists emails
(
    email_id int,
    user_id int,
    signup_date DATETIME
);

insert into emails VALUES (125,7771,'06/14/2022 00:00:00'),(236,6950,'07/01/2022 00:00:00'),(433,1052,'07/09/2022 00:00:00');

select * from emails;

--texts Table:
create table if not exists texts
(
    text_id int,
    email_id int,
    signup_action VARCHAR(50)
);

insert into texts VALUES (6878,125,'Confirmed'),(6920,236,'Not Confirmed'),(6994,236,'Confirmed');

select * from texts;


--Write a query to find the confirmation rate of users who confirmed their signups with text messages. Round the result to 2 decimal places.
SELECT
  ROUND(SUM(signup)::DECIMAL / COUNT(user_id), 2) AS confirmation_rate
FROM (
  SELECT
    user_id,
    CASE WHEN texts.email_id IS NOT NULL THEN 1
      ELSE 0 END AS signup
  FROM emails
  LEFT JOIN texts
    ON emails.email_id = texts.email_id
    AND signup_action = 'Confirmed'
) AS rate;



--Q170.
--tweets Table:
create table if not exists tweets
(
    tweet_id int,
    user_id int,
    tweet_date timestamp
);

insert into tweets VALUES (214252,111,'06/01/2022 12:00:00'),(739252,111,'06/01/2022 12:00:00'),(846402,111,'06/02/2022 12:00:00'),(241425,254,'06/02/2022 12:00:00'),(137374,111,'06/04/2022 12:00:00');

select * from tweets;


--Calculate the 3-day rolling average of tweets published by each user for each date that a tweet was posted. Output the user id, tweet date, and rolling averages rounded to 2 decimal places.
SELECT
  user_id,
  tweet_date,
  ROUND(
    AVG(tweet_num) OVER (
      PARTITION BY user_id
      ORDER BY user_id, tweet_date
      ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 2)
  AS rolling_avg_3d
FROM (
  SELECT
    user_id,
    tweet_date,
    COUNT(DISTINCT tweet_id) AS tweet_num
  FROM tweets
  GROUP BY user_id, tweet_date) AS tweet_count;


--Q171.
--activities Table:
create table if not exists activities
(
    activity_id int,
    user_id int,
    activity_type enum ('send', 'open', 'chat'),
    time_spent FLOAT,
    activity_date DATETIME
);

insert into activities VALUES (7274,123,'open',4.50,'06/22/2022 12:00:00'),(2425,123,'send',3.50,'06/22/2022 12:00:00'),(1413,456,'send',5.67,'06/23/2022 12:00:00'),(1414,789,'chat',11.00,'06/25/2022 12:00:00'),(2536,456,'open',3.00,'06/25/2022 12:00:00');

select * from activities;


--age_breakdown Table:
create table if not exists age_breakdown
(
    user_id int,
    age_bucket varchar(50)
);

insert into age_breakdown VALUES (123,'31-35'),(456,'26-30'),(789,'21-25');

select * from age_breakdown;

--Write a query to obtain a breakdown of the time spent sending vs. opening snaps (as a percentage of total time spent on these activities) for each age group.




--Q172 .
--personal_profiles Table:
create table if not exists personal_profiles
(
    profile_id int,
    name varchar(50),
    followers int
);

insert into personal_profiles VALUES (1,'Nick Singh',92000),(2,'Zach Wilson',199000),(3,'Daliana Liu',171000),(4,'Ravit Jain',107000),(5,'Vin Vashishta',139000),(6,'Susan Wojcicki',39000);

select * from personal_profiles;

--employee_company Table:
create table if not exists employee_company
(
    personal_profile_id int,
    company_id int
);

insert into employee_company VALUES (1,4),(1,9),(2,2),(3,1),(4,3),(5,6),(6,5);

select * from employee_company;

--company_pages Table:
create table if not exists company_pages
(
    company_id int,
    name VARCHAR(50),
    followers int
);

insert into company_pages VALUES (1,'The Data Science Podcast',8000),(2,'Airbnb',700000),(3,'The Ravit Show',6000),(4,'DataLemur',200),(5,'YouTube',16000000),(9,'Ace The Data Science Interview',4479);

select * from company_pages;



